<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bandai TCG History Analyzer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700;800&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --primary: #2E4057;
            --accent:  #048A81;
            --gold:    #c9a84c;
            --gold-lt: #e8c96a;
            --bg:      #f0f4f8;
            --card:    #ffffff;
            --text:    #1a1a2e;
            --muted:   #6c757d;
            --border:  #dee2e6;
            --win:     #28a745;
            --loss:    #dc3545;
            --wave-fill: #f0f4f8;
        }
        [data-theme="dark"] {
            --primary: #7eb8d4;
            --accent:  #2ecfc5;
            --gold:    #e8c96a;
            --gold-lt: #f5df9a;
            --bg:      #0f1923;
            --card:    #1a2535;
            --text:    #e8edf2;
            --muted:   #8a9bb0;
            --border:  #2a3a50;
            --win:     #4cbb6e;
            --loss:    #f0546a;
            --wave-fill: #0f1923;
        }
        /* Dark mode element overrides */
        [data-theme="dark"] body {
            background-image:
                radial-gradient(circle at 15% 50%, rgba(46,207,197,0.05) 0%, transparent 50%),
                radial-gradient(circle at 85% 20%, rgba(126,184,212,0.04) 0%, transparent 50%);
        }
        [data-theme="dark"] tbody tr:nth-child(even) td { background: #1f2f42; }
        [data-theme="dark"] tbody tr:hover td { background: #253647; }
        [data-theme="dark"] .stat-box { background: linear-gradient(160deg, #1a2535, #1f3045); }
        [data-theme="dark"] .rivalry-card { background: linear-gradient(160deg, #1a2535, #1f3045); }
        [data-theme="dark"] select,
        [data-theme="dark"] textarea,
        [data-theme="dark"] input[type="text"],
        [data-theme="dark"] input[type="date"] { background: #1a2535; color: var(--text); border-color: var(--border); }
        [data-theme="dark"] .player-autocomplete { background: #1a2535; border-color: var(--border); }
        [data-theme="dark"] .player-autocomplete li:hover,
        [data-theme="dark"] .player-autocomplete li.highlighted { background: #253647; }
        [data-theme="dark"] .vs-banner { background: #1a3040; border-color: var(--accent); }
        [data-theme="dark"] .inspector-block { background: #0d1117; }
        [data-theme="dark"] .cache-bar { background: var(--card); border-color: var(--border); }
        [data-theme="dark"] .cache-bar.has-cache { background: #1a3040; border-color: var(--accent); }
        [data-theme="dark"] .tier-bar-wrap { background: #2a3a50; }
        [data-theme="dark"] .round-opp-card { background: #1a2535; border-color: var(--border); }
        [data-theme="dark"] thead th { background: linear-gradient(135deg, #1a2d42, #253d56); }

        /* Theme toggle button */
        .theme-toggle {
            position: absolute;
            top: 1.1rem;
            right: 1.5rem;
            background: rgba(255,255,255,0.1);
            border: 1.5px solid rgba(201,168,76,0.4);
            color: white;
            border-radius: 999px;
            padding: 0.3rem 0.85rem;
            font-size: 0.78rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: background 0.2s, border-color 0.2s;
            z-index: 10;
        }
        .theme-toggle:hover { background: rgba(255,255,255,0.18); border-color: var(--gold-lt); }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            background-image:
                radial-gradient(circle at 15% 50%, rgba(4,138,129,0.04) 0%, transparent 50%),
                radial-gradient(circle at 85% 20%, rgba(46,64,87,0.05) 0%, transparent 50%);
        }

        header {
            background: linear-gradient(135deg, #1a2a3e 0%, var(--primary) 50%, #1e3a4a 100%);
            color: white;
            padding: 2rem 2rem 0;
            position: relative;
            overflow: hidden;
        }
        header::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image:
                radial-gradient(ellipse at 80% 50%, rgba(201,168,76,0.08) 0%, transparent 60%),
                repeating-linear-gradient(45deg, transparent, transparent 60px, rgba(255,255,255,0.01) 60px, rgba(255,255,255,0.01) 61px);
            pointer-events: none;
        }
        .header-inner {
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 1rem 1.75rem;
            position: relative;
            display: flex;
            align-items: center;
            gap: 1.25rem;
        }
        .header-skull {
            font-size: 2.8rem;
            line-height: 1;
            filter: drop-shadow(0 0 12px rgba(201,168,76,0.5));
            flex-shrink: 0;
        }
        .header-text h1 {
            font-family: 'Cinzel', serif;
            font-size: 1.65rem;
            font-weight: 800;
            letter-spacing: 0.04em;
            background: linear-gradient(90deg, #ffffff 0%, var(--gold-lt) 60%, #ffffff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.2;
        }
        .header-text p {
            font-size: 0.8rem;
            opacity: 0.65;
            margin-top: 0.3rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }
        .header-divider {
            width: 100%;
            line-height: 0;
            display: block;
        }
        .header-divider svg { display: block; width: 100%; }

        .container { max-width: 1100px; margin: 1.5rem auto; padding: 0 1rem; }

        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.07), 0 1px 3px rgba(0,0,0,0.05);
            margin-bottom: 1.5rem;
            border: 1px solid rgba(201,168,76,0.15);
            border-top: 3px solid var(--gold);
            transition: box-shadow 0.2s;
        }
        .card:hover { box-shadow: 0 6px 28px rgba(0,0,0,0.1), 0 0 0 1px rgba(201,168,76,0.2); }
        .card h2 {
            font-family: 'Cinzel', serif;
            font-size: 0.82rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--primary);
            margin-bottom: 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .card h2 .section-icon { font-size: 1rem; }

        label { display: block; font-size: 0.8rem; font-weight: 600; margin-bottom: 0.4rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.04em; }

        select {
            width: 100%; padding: 0.65rem 0.9rem; border: 1px solid var(--border);
            border-radius: 7px; font-size: 0.95rem; background: white; cursor: pointer;
            color: var(--text); appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236c757d' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat; background-position: right 0.9rem center;
            transition: border-color 0.2s;
        }
        select:focus   { outline: none; border-color: var(--accent); }
        select:disabled { background-color: #f5f5f5; cursor: not-allowed; color: var(--muted); }

        textarea { width: 100%; padding: 0.65rem 0.9rem; border: 1px solid var(--border); border-radius: 7px; font-size: 0.85rem; font-family: monospace; resize: vertical; height: 130px; transition: border-color 0.2s; }
        textarea:focus { outline: none; border-color: var(--accent); }

        .btn { display: inline-flex; align-items: center; gap: 0.45rem; padding: 0.65rem 1.5rem; border: none; border-radius: 8px; cursor: pointer; font-size: 0.88rem; font-weight: 600; transition: all 0.18s; letter-spacing: 0.02em; }
        .btn:hover   { opacity: 0.9; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
        .btn:active  { transform: scale(0.98) translateY(0); }
        .btn:disabled { opacity: 0.45; cursor: not-allowed; transform: none; box-shadow: none; }
        .btn-primary { background: linear-gradient(135deg, var(--accent), #036b64); color: white; box-shadow: 0 2px 8px rgba(4,138,129,0.3); }
        .btn-outline { background: transparent; border: 1.5px solid var(--gold); color: var(--primary); }
        .btn-outline:hover { background: rgba(201,168,76,0.08); border-color: var(--gold); }
        .btn-file    { background: transparent; border: 1.5px solid var(--border); color: var(--text); padding: 0.5rem 1rem; font-size: 0.84rem; }
        .btn-file:hover { border-color: var(--gold); color: var(--primary); }
        .btn-sm      { padding: 0.4rem 1rem; font-size: 0.8rem; }

        .file-row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
        .file-status { font-size: 0.82rem; color: var(--muted); }
        .file-status.ok { color: var(--win); font-weight: 600; }
        .file-status.warn { color: #e67e22; font-weight: 600; }

        #progress { display: none; }
        .progress-bar-wrap { background: var(--border); border-radius: 999px; height: 6px; margin-top: 0.75rem; overflow: hidden; }
        .progress-bar { height: 6px; border-radius: 999px; background: linear-gradient(90deg, var(--accent), #2E9E8F); transition: width 0.4s ease; }
        #progressText { font-size: 0.85rem; color: var(--muted); }

        #results { display: none; }

        .stat-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; }
        @media (max-width: 600px) { .stat-grid { grid-template-columns: repeat(2, 1fr); } }
        .stat-box {
            text-align: center;
            padding: 1.35rem 1rem;
            background: linear-gradient(160deg, var(--bg) 0%, #eaf0fb 100%);
            border-radius: 10px;
            border: 1px solid var(--border);
            border-bottom: 2px solid var(--gold);
            transition: transform 0.15s, box-shadow 0.15s;
        }
        .stat-box:hover { transform: translateY(-2px); box-shadow: 0 4px 14px rgba(201,168,76,0.15); }
        .stat-box .val { font-size: 2.1rem; font-weight: 800; line-height: 1; font-family: 'Cinzel', serif; }
        .stat-box .lbl { font-size: 0.68rem; color: var(--muted); margin-top: 0.45rem; text-transform: uppercase; letter-spacing: 0.08em; }
        .w-val   { color: var(--win); }
        .l-val   { color: var(--loss); }
        .pct-val { color: var(--accent); }
        .t-val   { color: var(--primary); }

        .table-wrap { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: 0.87rem; }
        thead th { background: linear-gradient(135deg, var(--primary), #3d5472); color: white; padding: 0.65rem 0.9rem; text-align: left; cursor: pointer; user-select: none; white-space: nowrap; font-family: 'Cinzel', serif; font-size: 0.75rem; letter-spacing: 0.05em; }
        thead th:hover { background: #3d5472; }
        thead th.sorted-asc::after  { content: " ▲"; font-size: 0.7rem; }
        thead th.sorted-desc::after { content: " ▼"; font-size: 0.7rem; }
        tbody td { padding: 0.55rem 0.9rem; border-bottom: 1px solid var(--border); }
        tbody tr:nth-child(even) td { background: #EAF0FB; }
        tbody tr:hover td { background: #d5e4f5; }
        .td-num { text-align: center; }
        .td-pct { text-align: center; font-weight: 600; }

        .row-flex { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.25rem; }
        .row-flex h2 { margin-bottom: 0; }

        .error-box { background: #fff5f5; border: 1.5px solid #ffcccc; color: #c0392b; padding: 1.1rem 1.25rem; border-radius: 8px; font-size: 0.88rem; line-height: 1.6; margin-bottom: 1.5rem; }
        .error-box code { background: #ffe8e8; padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.82rem; }

        details summary { cursor: pointer; font-size: 0.82rem; color: var(--accent); font-weight: 600; padding: 0.5rem 0; }
        details summary:hover { text-decoration: underline; }
        details > .details-body { margin-top: 0.5rem; }

        .step { margin-bottom: 1.1rem; }
        .step:last-child { margin-bottom: 0; }
        hr { border: none; border-top: 1px solid var(--border); margin: 1.25rem 0; }

        .hint { font-size: 0.78rem; color: var(--muted); margin-top: 0.4rem; }
        .hint code { background: #f0f0f0; padding: 0.1rem 0.35rem; border-radius: 3px; font-size: 0.78rem; }

        .cache-bar { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem;
            background: var(--bg); border: 1px solid var(--border); border-radius: 7px;
            padding: 0.6rem 0.9rem; font-size: 0.82rem; color: var(--muted); }
        .cache-bar strong { color: var(--text); }
        .cache-bar.has-cache { border-color: var(--accent); background: #f0faf9; }
        .cache-actions { display: flex; gap: 0.4rem; }
        .btn-danger { background: transparent; border: 1.5px solid var(--loss); color: var(--loss); }
        .btn-danger:hover { background: var(--loss); color: white; }

        .chip-row { display: flex; flex-wrap: wrap; gap: 0.4rem; }
        .chip { display: inline-flex; align-items: center; padding: 0.3rem 0.75rem; border-radius: 999px; font-size: 0.78rem; font-weight: 600; cursor: pointer; border: 1.5px solid var(--border); background: white; color: var(--muted); transition: all 0.15s; user-select: none; }
        .chip:hover { border-color: var(--gold); color: var(--primary); }
        .chip.active { background: var(--primary); border-color: var(--gold); color: white; box-shadow: 0 0 0 1px var(--gold); }
        .chip.chip-all { border-color: var(--primary); color: var(--primary); }
        .chip.chip-all.active { background: var(--primary); border-color: var(--primary); color: white; }

        .filter-row { display: flex; flex-wrap: wrap; gap: 1rem; align-items: flex-end; margin-top: 1rem; }
        .filter-group { display: flex; flex-direction: column; gap: 0.3rem; }
        .filter-group label { margin-bottom: 0; }
        .filter-group input[type="date"] {
            padding: 0.5rem 0.7rem; border: 1px solid var(--border); border-radius: 7px;
            font-size: 0.88rem; color: var(--text); background: white; cursor: pointer;
            transition: border-color 0.2s;
        }
        .filter-group input[type="date"]:focus { outline: none; border-color: var(--accent); }

        .player-search-wrap { position: relative; }
        .player-search-wrap input[type="text"] {
            width: 100%; padding: 0.55rem 0.9rem; border: 1px solid var(--border); border-radius: 7px;
            font-size: 0.88rem; color: var(--text); transition: border-color 0.2s;
        }
        .player-search-wrap input[type="text"]:focus { outline: none; border-color: var(--accent); }
        .player-autocomplete { position: absolute; top: 100%; left: 0; right: 0; z-index: 100;
            background: white; border: 1px solid var(--border); border-top: none;
            border-radius: 0 0 7px 7px; max-height: 220px; overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: none; }
        .player-autocomplete li { list-style: none; padding: 0.5rem 0.9rem; cursor: pointer; font-size: 0.88rem; }
        .player-autocomplete li:hover, .player-autocomplete li.highlighted { background: #EAF0FB; }

        .vs-banner { display: none; align-items: center; gap: 0.75rem; padding: 0.6rem 0.9rem;
            background: #f0faf9; border: 1.5px solid var(--accent); border-radius: 7px; margin-bottom: 1rem; font-size: 0.88rem; }
        .vs-banner strong { color: var(--accent); }
        .vs-banner .btn-clear { margin-left: auto; }

        tbody tr.row-highlight td { background: #fffbe6 !important; font-weight: 600; }

        .card-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; padding-bottom: 1rem; border-bottom: 1px solid rgba(201,168,76,0.2); margin-bottom: 1.25rem; }
        .card-header h2 { margin-bottom: 0; }
        .card-header .toggle-icon { font-size: 0.75rem; color: var(--gold); transition: transform 0.2s; }
        .card-body { overflow: hidden; transition: max-height 0.3s ease, opacity 0.2s ease; }
        .card-body.collapsed { max-height: 0 !important; opacity: 0; pointer-events: none; }

        /* Streak stats */
        .streak-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:1rem; margin-top:1rem; }
        @media (max-width:500px) { .streak-grid { grid-template-columns:1fr 1fr; } }

        /* Opponent modal */
        .modal-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45); z-index:1000; align-items:center; justify-content:center; padding:1rem; }
        .modal-overlay.open { display:flex; }
        .modal-box { background:var(--card); border-radius:14px; padding:1.75rem; max-width:640px; width:100%; max-height:85vh; overflow-y:auto; box-shadow:0 12px 50px rgba(0,0,0,0.3); position:relative; border-top:3px solid var(--gold); }
        .modal-close { position:absolute; top:0.85rem; right:1rem; background:none; border:none; font-size:1.2rem; cursor:pointer; color:var(--muted); padding:0.2rem; line-height:1; }
        .modal-close:hover { color:var(--text); }
        .modal-title { font-size:1.05rem; font-weight:700; color:var(--primary); margin-bottom:0.2rem; }
        .modal-sub { font-size:0.82rem; color:var(--muted); margin-bottom:1.25rem; }
        .modal-section h3 { font-size:0.75rem; text-transform:uppercase; letter-spacing:0.06em; color:var(--muted); font-weight:700; margin-bottom:0.6rem; margin-top:1.25rem; }

        /* API Field Inspector */
        .inspector-section { margin-bottom: 1.25rem; }
        .inspector-section h3 { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.07em; color: var(--muted); font-weight: 700; margin-bottom: 0.5rem; }
        .inspector-block { position: relative; background: #1e1e2e; color: #cdd6f4; font-family: monospace; font-size: 0.78rem; line-height: 1.6; padding: 1rem; border-radius: 8px; overflow-x: auto; white-space: pre; max-height: 340px; overflow-y: auto; }
        .inspector-copy { position: absolute; top: 0.5rem; right: 0.5rem; background: #313244; color: #cdd6f4; border: 1px solid #45475a; border-radius: 5px; padding: 0.2rem 0.6rem; font-size: 0.72rem; cursor: pointer; }
        .inspector-copy:hover { background: #45475a; }
        .inspector-key   { color: #89dceb; }
        .inspector-str   { color: #a6e3a1; }
        .inspector-num   { color: #fab387; }
        .inspector-bool  { color: #cba6f7; }
        .inspector-null  { color: #6c7086; }

        /* Placement tiers */
        .tier-row { display:flex; align-items:center; gap:0.75rem; margin-bottom:0.65rem; }
        .tier-label { font-size:0.75rem; font-weight:700; font-family:'Cinzel',serif; color:var(--primary); width:5.5rem; flex-shrink:0; }
        .tier-bar-wrap { flex:1; background:var(--border); border-radius:999px; height:14px; overflow:hidden; }
        .tier-bar { height:100%; border-radius:999px; transition:width 0.6s ease; }
        .tier-count { font-size:0.78rem; font-weight:700; color:var(--primary); width:2rem; text-align:right; flex-shrink:0; }
        .tier-pct   { font-size:0.72rem; color:var(--muted); width:3rem; flex-shrink:0; }

        /* Most Faced per Round mini-cards */
        #roundOppGrid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.75rem; }
        @media (max-width: 700px) { #roundOppGrid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 430px) { #roundOppGrid { grid-template-columns: repeat(2, 1fr); } }
        .round-opp-card { background: var(--bg); border: 1.5px solid var(--border); border-radius: 8px; padding: 0.75rem 0.6rem; text-align: center; cursor: pointer; transition: border-color 0.15s, box-shadow 0.15s; }
        .round-opp-card:hover { border-color: var(--accent); box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
        .round-opp-card .roc-round { font-size: 0.65rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.07em; color: var(--muted); margin-bottom: 0.3rem; }
        .round-opp-card .roc-name  { font-size: 0.82rem; font-weight: 700; color: var(--primary); margin-bottom: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .round-opp-card .roc-count { font-size: 0.75rem; color: var(--muted); }
        .round-opp-card .roc-record{ font-size: 0.78rem; font-weight: 600; margin-top: 0.2rem; }

        /* Bogeyman / Victim rivalry cards */
        .rivalry-grid { display:grid; grid-template-columns:1fr 1fr; gap:1rem; margin-top:1rem; }
        @media (max-width:560px) { .rivalry-grid { grid-template-columns:1fr; } }
        .rivalry-card { border-radius:10px; border:1.5px solid var(--border); padding:1rem 1.25rem; cursor:pointer; transition:all 0.18s; background: linear-gradient(160deg, var(--bg), #eaf0fb); }
        .rivalry-card:hover { border-color:var(--gold); box-shadow:0 4px 16px rgba(201,168,76,0.18); transform: translateY(-2px); }
        .rivalry-card.bogeyman { border-left:4px solid var(--loss); }
        .rivalry-card.victim   { border-left:4px solid var(--win); }
        .rivalry-label { font-size:0.68rem; font-weight:700; text-transform:uppercase; letter-spacing:0.08em; margin-bottom:0.35rem; }
        .rivalry-card.bogeyman .rivalry-label { color:var(--loss); }
        .rivalry-card.victim   .rivalry-label { color:var(--win); }
        .rivalry-name  { font-size:1.05rem; font-weight:700; color:var(--primary); margin-bottom:0.3rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .rivalry-record{ font-size:0.88rem; color:var(--muted); }
        .rivalry-record strong { font-size:1.35rem; font-weight:800; }
        .rivalry-card.bogeyman .rivalry-record strong { color:var(--loss); }
        .rivalry-card.victim   .rivalry-record strong { color:var(--win); }

        /* Multi-user comparison */
        .compare-cols { display:grid; grid-template-columns:1fr 1fr; gap:1.5rem; }
        @media (max-width:600px) { .compare-cols { grid-template-columns:1fr; } }
        .compare-user-box { background:var(--bg); border:1.5px solid var(--border); border-radius:8px; padding:1.1rem; }
        .compare-user-box.compare-active { border-color:var(--accent); }
        .compare-user-box h3 { font-size:0.8rem; text-transform:uppercase; letter-spacing:0.06em; color:var(--muted); margin-bottom:0.75rem; font-weight:700; }
        .compare-bar-wrap { margin-top:0.75rem; }
        .compare-bar-label { display:flex; justify-content:space-between; font-size:0.78rem; color:var(--muted); margin-bottom:0.25rem; }
        .compare-bar { height:6px; border-radius:999px; background:var(--border); overflow:hidden; }
        .compare-bar-fill { height:100%; border-radius:999px; background:var(--accent); }
        .compare-winner { color:var(--win) !important; font-weight:700; }

        .charts-grid { display: grid; grid-template-columns: 1fr 2fr; gap: 1.5rem; align-items: start; }
        @media (max-width: 720px) { .charts-grid { grid-template-columns: 1fr; } }
        .chart-panel { display: flex; flex-direction: column; gap: 0.5rem; }
        .chart-panel h3 { font-family: 'Cinzel', serif; font-size: 0.76rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--primary); font-weight: 700; }
        .chart-canvas-wrap { position: relative; height: 280px; }
        .chart-canvas-wrap.tall { height: 380px; }
        .chart-canvas-wrap.short { height: 200px; }

        /* PDF toolbar */
        .pdf-toolbar { display: flex; justify-content: flex-end; margin-bottom: 1rem; }

        /* ── Tab Navigation ─────────────────────────────────────────────── */
        .tab-nav {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
        }
        .tab-btn {
            padding: 0.65rem 1.6rem;
            border: none;
            background: none;
            font-family: 'Cinzel', serif;
            font-size: 0.8rem;
            letter-spacing: 0.07em;
            color: var(--muted);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: color 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .tab-btn.active { color: var(--gold); border-bottom-color: var(--gold); font-weight: 700; }
        .tab-btn:hover:not(.active) { color: var(--text); border-bottom-color: var(--border); }

        /* ── Global Rankings ─────────────────────────────────────────────── */
        .rank-medal { font-size: 1.1rem; }
        .h2h-table { border-collapse: collapse; font-size: 0.82rem; width: 100%; }
        .h2h-table th { background: linear-gradient(135deg, var(--primary), #3d5472); color: white;
            padding: 0.5rem 0.75rem; text-align: center; font-family: 'Cinzel', serif;
            font-size: 0.72rem; letter-spacing: 0.04em; white-space: nowrap; }
        .h2h-table td { padding: 0.45rem 0.75rem; border: 1px solid var(--border); text-align: center; }
        .h2h-table td.h2h-self { background: var(--border); color: var(--muted); }
        .h2h-table td.h2h-win { background: rgba(40,167,69,0.12); color: var(--win); font-weight: 700; }
        .h2h-table td.h2h-loss { background: rgba(220,53,69,0.1); color: var(--loss); font-weight: 700; }
        .h2h-table td.h2h-label { text-align: left; font-weight: 600; padding-left: 0.9rem; white-space: nowrap; }
        [data-theme="dark"] .h2h-table td.h2h-win  { background: rgba(76,187,110,0.15); }
        [data-theme="dark"] .h2h-table td.h2h-loss { background: rgba(240,84,106,0.15); }
        .standings-details { margin-bottom: 0.85rem; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        .standings-details summary {
            padding: 0.7rem 1rem; cursor: pointer; font-weight: 600;
            font-size: 0.85rem; list-style: none; display: flex;
            justify-content: space-between; align-items: center;
            background: var(--bg); color: var(--text);
        }
        .standings-details summary::-webkit-details-marker { display: none; }
        .standings-details[open] summary { border-bottom: 1px solid var(--border); }
        .standings-details .standings-inner { padding: 0.75rem; }

        /* ── Podium sort bar ────────────────────────────────────────────── */
        .podium-sort-bar {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 1.25rem;
            flex-wrap: wrap;
        }
        .podium-sort-btn {
            padding: 0.3rem 0.85rem;
            border: 1.5px solid var(--border);
            border-radius: 999px;
            background: none;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--muted);
            cursor: pointer;
            transition: all 0.18s;
            letter-spacing: 0.02em;
        }
        .podium-sort-btn:hover { border-color: var(--gold); color: var(--text); }
        .podium-sort-btn.active {
            background: linear-gradient(135deg, var(--gold), var(--gold-lt));
            border-color: var(--gold);
            color: #1a1a2e;
        }

        /* ── Podium ─────────────────────────────────────────────────────── */
        .podium-stage {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 0.75rem;
            padding: 0 1rem 0;
            min-height: 260px;
        }
        .podium-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            max-width: 160px;
        }
        .podium-avatar {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.55rem;
            font-weight: 800;
            font-family: 'Cinzel', serif;
            color: white;
            margin-bottom: 0.4rem;
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            position: relative;
        }
        .podium-medal {
            position: absolute;
            bottom: -6px;
            right: -6px;
            font-size: 1.05rem;
            line-height: 1;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));
        }
        .podium-name {
            font-size: 0.78rem;
            font-weight: 700;
            text-align: center;
            color: var(--text);
            margin-bottom: 0.2rem;
            max-width: 130px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .podium-pct {
            font-family: 'Cinzel', serif;
            font-size: 1.05rem;
            font-weight: 800;
            color: var(--accent);
            margin-bottom: 0.45rem;
        }
        .podium-sub {
            font-size: 0.68rem;
            color: var(--muted);
            margin-bottom: 0.5rem;
            text-align: center;
            line-height: 1.4;
        }
        .podium-bar {
            width: 100%;
            border-radius: 8px 8px 0 0;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 0.6rem;
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            font-weight: 800;
            color: rgba(255,255,255,0.85);
            transition: height 0.6s cubic-bezier(.34,1.56,.64,1);
        }
        /* rank-specific heights and colors */
        .podium-slot[data-pos="1"] .podium-bar { height: 155px; background: linear-gradient(180deg,#d4a017,#c9a84c); box-shadow: 0 -4px 18px rgba(201,168,76,0.45); }
        .podium-slot[data-pos="2"] .podium-bar { height: 115px; background: linear-gradient(180deg,#8a9bb0,#6b7f95); box-shadow: 0 -4px 14px rgba(107,127,149,0.35); }
        .podium-slot[data-pos="3"] .podium-bar { height: 90px;  background: linear-gradient(180deg,#b87333,#9c5e24); box-shadow: 0 -4px 12px rgba(184,115,51,0.35); }
        .podium-slot[data-pos="4"] .podium-bar { height: 68px;  background: linear-gradient(180deg,#4a6080,#3a4e68); }
        .podium-slot[data-pos="5"] .podium-bar { height: 50px;  background: linear-gradient(180deg,#3d5472,#2e4057); }
        .podium-slot[data-pos="1"] .podium-avatar { background: linear-gradient(135deg,#e8c96a,#c9a84c); border: 3px solid #e8c96a; }
        .podium-slot[data-pos="2"] .podium-avatar { background: linear-gradient(135deg,#a8b8cc,#8a9bb0); border: 3px solid #a8b8cc; }
        .podium-slot[data-pos="3"] .podium-avatar { background: linear-gradient(135deg,#d4956a,#b87333); border: 3px solid #d4956a; }
        .podium-slot[data-pos="4"] .podium-avatar { background: linear-gradient(135deg,#5b7a9d,#4a6080); border: 3px solid #5b7a9d; }
        .podium-slot[data-pos="5"] .podium-avatar { background: linear-gradient(135deg,#4a6080,#3a4e68); border: 3px solid #4a6080; }
        .podium-slot[data-pos="1"] .podium-pct { color: var(--gold); }
        .podium-floor {
            height: 6px;
            background: linear-gradient(90deg, var(--border), var(--gold) 50%, var(--border));
            border-radius: 3px;
            margin-top: 0;
        }
        [data-theme="dark"] .podium-slot[data-pos="1"] .podium-bar { box-shadow: 0 -4px 22px rgba(232,201,106,0.4); }
        @media (max-width: 600px) {
            .podium-stage { gap: 0.4rem; }
            .podium-slot { max-width: 80px; }
            .podium-avatar { width: 40px; height: 40px; font-size: 1.1rem; }
            .podium-name { font-size: 0.68rem; }
            .podium-pct  { font-size: 0.85rem; }
        }

        /* ── Print / PDF styles ─────────────────────────────────────────── */
        @media print {
            /* Hide UI chrome */
            header, #configCard, #progress, #errorBox, #filterCard,
            #inspectorCard, .pdf-toolbar, .cache-bar, .modal-overlay,
            .toggle-icon, .btn, #vsBanner, .player-search-wrap > input,
            #playerAutocomplete, .tab-nav, #rankingsTab { display: none !important; }

            /* Show all card bodies, even collapsed ones */
            .card-body, .card-body.collapsed {
                display: block !important;
                max-height: none !important;
                opacity: 1 !important;
                overflow: visible !important;
                pointer-events: auto !important;
            }

            /* Layout — always print light */
            :root, [data-theme="dark"] {
                --bg: #ffffff; --card: #ffffff; --text: #1a1a2e;
                --muted: #6c757d; --border: #dee2e6; --primary: #2E4057;
            }
            body { background: white; }
            .container { max-width: 100%; margin: 0; padding: 0.25rem 0.5rem; }
            .card { box-shadow: none !important; border: 1px solid #dee2e6; border-top: 1px solid #dee2e6; margin-bottom: 0.75rem; padding: 1rem; }
            .card:hover { box-shadow: none !important; transform: none; }
            header::before, header .header-divider { display: none; }
            .stat-box:hover, .rivalry-card:hover, .btn:hover { transform: none; box-shadow: none; }
            .card h2 { margin-bottom: 0.75rem; }

            /* Avoid breaking inside small cards; allow breaks between big ones */
            .card { break-inside: avoid; }
            #tourneyCard, #playerCard, #chartsCard { break-inside: auto; }
            .rivalry-grid { grid-template-columns: 1fr 1fr; }
            .rivalry-card { cursor: default; }
            thead { display: table-header-group; }
            tr { break-inside: avoid; }

            /* Charts */
            .charts-grid { grid-template-columns: 1fr 2fr; }
            canvas { max-width: 100% !important; }
            .chart-canvas-wrap, .chart-canvas-wrap.tall, .chart-canvas-wrap.short { height: auto !important; }

            /* Stat boxes */
            .stat-grid { grid-template-columns: repeat(4, 1fr); }
            .streak-grid { grid-template-columns: repeat(3, 1fr); }

            /* Comparison columns */
            .compare-cols { grid-template-columns: 1fr 1fr; }

            /* Placement tier bars — disable transition so bars render at full width */
            .tier-bar { transition: none !important; }
            .tier-bar-wrap { overflow: visible !important; }
        }

        /* Round-by-round heatmap */
        .heatmap-table { border-collapse: collapse; font-size: 0.75rem; }
        .heatmap-table th {
            background: linear-gradient(135deg, var(--primary), #3d5472);
            color: white; padding: 0.3rem 0.5rem;
            font-family: 'Cinzel', serif; font-size: 0.68rem; text-align: center;
        }
        .heatmap-table td { padding: 0.25rem 0.35rem; border: 1px solid var(--border); text-align: center; }
        .heatmap-dot { display: inline-block; width: 14px; height: 14px; border-radius: 3px; }
        .heatmap-dot.win  { background: var(--win); }
        .heatmap-dot.loss { background: var(--loss); }
        .heatmap-dot.none { background: var(--border); opacity: 0.4; }
        .heatmap-pct-row td { font-weight: 700; font-size: 0.72rem; background: var(--bg); border-top: 2px solid var(--border); }


    </style>
</head>
<body>

<header>
    <button class="theme-toggle" onclick="toggleTheme()" id="themeToggleBtn">&#127775; Light</button>
    <div class="header-inner">
        <div class="header-skull">&#9760;&#65039;</div>
        <div class="header-text">
            <h1>One Piece TCG · History Analyzer</h1>
            <p>&#9875; Track your voyage across the Grand Line of tournaments</p>
        </div>
    </div>
    <div class="header-divider">
        <svg viewBox="0 0 1440 40" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg" id="waveSvg">
            <path id="wavePath" d="M0,20 C240,40 480,0 720,20 C960,40 1200,0 1440,20 L1440,40 L0,40 Z" fill="#f0f4f8"/>
        </svg>
    </div>
</header>

<div class="container">

    <!-- Config card -->
    <div class="card" id="configCard">
        <h2><span class="section-icon">&#9875;</span> Configuration</h2>

        <!-- Step 1: load file -->
        <div class="step">
            <label>1 · Username Map File</label>
            <div class="file-row">
                <input type="file" id="mapFile" accept=".txt" style="display:none" onchange="loadMapFile(event)">
                <button class="btn btn-file" onclick="document.getElementById('mapFile').click()">
                    &#128194; Load bandai_username_map.txt
                </button>
                <span class="file-status" id="fileStatus">No file loaded</span>
            </div>
            <p class="hint">
                Add a bearer token as a third field for any user who needs to fetch data:
                <code>Name:BandaiID:eyJ0eXAiOi...</code>
            </p>
        </div>

        <!-- Step 2: pick user -->
        <div class="step">
            <label for="userSelect">2 · Select User</label>
            <select id="userSelect" disabled onchange="onUserChange()">
                <option value="">— load the username map first —</option>
            </select>
            <!-- Cache status, shown after user is selected -->
            <div id="cacheBar" style="display:none; margin-top:0.6rem;">
                <div class="cache-bar" id="cacheBarInner">
                    <span id="cacheBarText"></span>
                    <div class="cache-actions">
                        <button class="btn btn-outline btn-sm" onclick="refreshCache()">&#8635; Sync new events only</button>
                        <button class="btn btn-danger btn-sm" onclick="confirmClearCache()">&#128465; Clear cache</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Fallback: paste manually -->
        <details id="manualDetails">
            <summary>Or paste the file contents manually</summary>
            <div class="details-body">
                <textarea id="usernameMap" placeholder="Name:BandaiID&#10;OtherName:BandaiID:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."></textarea>
                <button class="btn btn-outline btn-sm" style="margin-top:0.6rem" onclick="parsePasted()">Apply</button>
            </div>
        </details>

        <hr>

        <div style="display:flex;align-items:center;gap:0.6rem;flex-wrap:wrap;margin-top:0.9rem;">
            <button class="btn btn-primary" id="fetchBtn" onclick="fetchAndAnalyze()" disabled>
                &#9654; Fetch &amp; Analyze
            </button>
            <button class="btn btn-outline" id="syncAllBtn" onclick="syncAllUsers()" disabled title="Fetch new events for every user with a token">
                &#8635; Sync All Users
            </button>
            <span id="syncAllSummary" style="display:none;font-size:0.8rem;color:var(--win);font-weight:600;"></span>
        </div>
    </div>

    <!-- Progress -->
    <div id="progress" class="card">
        <p id="progressText">Starting…</p>
        <div class="progress-bar-wrap">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>
    </div>

    <!-- Error -->
    <div id="errorBox" style="display:none;"></div>

    <!-- Tab navigation (shown after first fetch) -->
    <div class="tab-nav" id="tabNav" style="display:none">
        <button class="tab-btn active" id="tabMyStats" onclick="switchTab('my-stats')">&#128202; My Stats</button>
        <button class="tab-btn" id="tabRankings" onclick="switchTab('rankings')">&#127942; Global Rankings</button>
    </div>

    <!-- Results -->
    <div id="results">

        <div class="pdf-toolbar">
            <button class="btn btn-outline" onclick="exportPDF()">&#128438; Export PDF</button>
            <button class="btn btn-outline" onclick="exportCSV()" style="margin-left:0.5rem;">&#128196; Export CSV</button>
            <button class="btn btn-outline" onclick="toggleInspector()" id="inspectorBtn" style="margin-left:0.5rem;">&#128269; Inspect API Fields</button>
        </div>

        <!-- API Field Inspector -->
        <div class="card" id="inspectorCard" style="display:none; margin-bottom:1rem;">
            <div class="card-header" onclick="toggleCard('inspector')">
                <h2><span class="section-icon">&#128269;</span> API Field Inspector</h2>
                <span class="toggle-icon" id="inspector-icon">▼</span>
            </div>
            <div class="card-body" id="inspector-body" style="max-height:9999px;">
                <p style="font-size:0.82rem;color:var(--muted);margin-bottom:1rem;">
                    Raw JSON from the first available event. Use this to discover all fields the Bandai API returns.
                    <strong style="color:var(--loss);">Remove this before sharing the file</strong> — it contains raw API data.
                </p>
                <div id="inspectorSections"></div>
            </div>
        </div>

        <!-- Filters card -->
        <div class="card" id="filterCard" style="display:none">
            <div class="card-header" onclick="toggleCard('filters')">
                <h2><span class="section-icon">&#9874;&#65039;</span> Filters</h2>
                <span class="toggle-icon" id="filters-icon">▼</span>
            </div>
            <div class="card-body" id="filters-body" style="max-height: 9999px;">

            <!-- Period chips -->
            <div class="chip-row" id="periodChips"></div>

            <!-- Year chips -->
            <div class="filter-row" style="margin-top:1rem;">
                <div class="chip-row" id="yearChips">
                    <button class="chip" data-year="2024" onclick="onYearChip(this)">2024</button>
                    <button class="chip" data-year="2025" onclick="onYearChip(this)">2025</button>
                    <button class="chip" data-year="2026" onclick="onYearChip(this)">2026</button>
                </div>
            </div>

            <!-- Date range -->
            <div class="filter-row" style="margin-top:0.5rem;">
                <div class="filter-group">
                    <label for="dateFrom">From</label>
                    <input type="date" id="dateFrom" onchange="onDateRangeChange()">
                </div>
                <div class="filter-group">
                    <label for="dateTo">To</label>
                    <input type="date" id="dateTo" onchange="onDateRangeChange()">
                </div>
                <button class="btn btn-outline btn-sm" onclick="clearDateFilter()" style="align-self:flex-end">&#10005; Clear dates</button>
            </div>

            <!-- Store filter -->
            <div class="filter-row" style="margin-top:0.75rem;">
                <div class="filter-group" style="flex:1; min-width:200px;">
                    <label for="storeSelect">Store</label>
                    <select id="storeSelect" onchange="onStoreChange()">
                        <option value="">— all stores —</option>
                    </select>
                </div>
                <button class="btn btn-outline btn-sm" onclick="clearStoreFilter()" style="align-self:flex-end">&#10005; Clear store</button>
            </div>

            <!-- Regionals toggle -->
            <div class="filter-row" style="margin-top:0.75rem;">
                <button id="regionalsOnlyBtn" class="chip" onclick="toggleRegionalsOnly()" title="Show only events listed in the Regionals section">
                    Regionals only
                </button>
            </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header" onclick="toggleCard('overall')">
                <h2><span class="section-icon">&#127381;</span> Overall Results</h2>
                <span class="toggle-icon" id="overall-icon">▼</span>
            </div>
            <div class="card-body" id="overall-body" style="max-height: 9999px;">
                <div class="stat-grid" id="overallStats"></div>
                <div style="font-size:0.65rem;text-transform:uppercase;letter-spacing:0.08em;color:var(--muted);margin:1.1rem 0 0.4rem;">Game &amp; Clutch Stats</div>
                <div class="stat-grid" id="gameStats"></div>
                <div id="streakStats"></div>
                <div id="bogeymanStats"></div>
                <div id="placementsInline" style="display:none; margin-top:1.5rem;">
                    <h3 style="font-family:'Cinzel',serif;font-size:0.76rem;text-transform:uppercase;letter-spacing:0.08em;color:var(--primary);font-weight:700;margin-bottom:1rem;">&#127942; Placement History</h3>
                    <div class="stat-grid" id="placementsStats" style="margin-bottom:1.25rem;"></div>
                    <div id="placementsTiers"></div>
                </div>
            </div>
        </div>

        <div class="card" id="chartsCard" style="display:none">
            <div class="card-header" onclick="toggleCard('charts')">
                <h2><span class="section-icon">&#128202;</span> Charts</h2>
                <span class="toggle-icon" id="charts-icon">▼</span>
            </div>
            <div class="card-body" id="charts-body" style="max-height: 9999px;">
                <div class="charts-grid">
                    <div class="chart-panel">
                        <h3>Win / Loss</h3>
                        <div class="chart-canvas-wrap short" style="max-width:240px; margin:0 auto;">
                            <canvas id="chartDonut"></canvas>
                        </div>
                    </div>
                    <div class="chart-panel">
                        <h3>Results by Set Period</h3>
                        <div class="chart-canvas-wrap">
                            <canvas id="chartPeriodBar"></canvas>
                        </div>
                    </div>
                </div>
                <div class="chart-panel" style="margin-top:1.5rem;" id="storeChartPanel">
                    <h3>Win Rate by Store</h3>
                    <p style="font-size:0.78rem;color:var(--muted);margin:-0.25rem 0 0.75rem;">Win % at each venue. Bar width reflects number of matches played there. Only stores with ≥ 2 matches shown.</p>
                    <div class="chart-canvas-wrap tall">
                        <canvas id="chartStore"></canvas>
                    </div>
                </div>
                <div class="chart-panel" style="margin-top:1.5rem;">
                    <h3>Streak History (per tournament)</h3>
                    <p style="font-size:0.78rem;color:var(--muted);margin:-0.25rem 0 0.75rem;">Running streak value after each tournament. Positive = win streak, negative = loss streak. Quickly shows hot and cold patches.</p>
                    <div class="chart-canvas-wrap">
                        <canvas id="chartStreak"></canvas>
                    </div>
                </div>
                <div class="chart-panel" style="margin-top:1.5rem;">
                    <h3>Win Rate Over Time (per tournament)</h3>
                    <p style="font-size:0.78rem;color:var(--muted);margin:-0.25rem 0 0.75rem;line-height:1.5;">
                        <strong style="color:var(--accent);">&#9644; Cumulative Win %</strong> — running win rate across all tournaments up to that point &nbsp;|&nbsp;
                        <strong style="color:var(--primary);">&#9135;&#9135; Rolling 5 Win %</strong> — win rate over the last 5 tournaments only (recent form)
                    </p>
                    <div class="chart-canvas-wrap">
                        <canvas id="chartTimeline"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="card" id="monthlyCard" style="display:none">
            <div class="card-header" onclick="toggleCard('monthly')">
                <h2><span class="section-icon">&#128197;</span> Results by Month</h2>
                <span class="toggle-icon" id="monthly-icon">▼</span>
            </div>
            <div class="card-body" id="monthly-body" style="max-height:9999px;">
                <div class="chart-panel" style="margin-bottom:1.5rem;">
                    <div class="chart-canvas-wrap">
                        <canvas id="chartMonthly"></canvas>
                    </div>
                </div>
                <div class="table-wrap">
                    <table id="monthlyTable">
                        <thead><tr>
                            <th onclick="sortTable('monthlyTable',0)">Month</th>
                            <th onclick="sortTable('monthlyTable',1)">W</th>
                            <th onclick="sortTable('monthlyTable',2)">L</th>
                            <th onclick="sortTable('monthlyTable',3)">Total</th>
                            <th onclick="sortTable('monthlyTable',4)">Win%</th>
                        </tr></thead>
                        <tbody id="monthlyBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header" onclick="toggleCard('period')">
                <h2><span class="section-icon">&#128218;</span> Results by Set Period</h2>
                <span class="toggle-icon" id="period-icon">▼</span>
            </div>
            <div class="card-body" id="period-body" style="max-height: 9999px;">
                <div class="table-wrap">
                    <table id="periodTable">
                        <thead><tr>
                            <th onclick="sortTable('periodTable',0)">Set Period</th>
                            <th onclick="sortTable('periodTable',1)">W</th>
                            <th onclick="sortTable('periodTable',2)">L</th>
                            <th onclick="sortTable('periodTable',3)">Total</th>
                            <th onclick="sortTable('periodTable',4)">Win%</th>
                        </tr></thead>
                        <tbody id="periodBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header" onclick="toggleCard('tourney')">
                <h2><span class="section-icon">&#9875;</span> Tournament History</h2>
                <span class="toggle-icon" id="tourney-icon">▼</span>
            </div>
            <div class="card-body" id="tourney-body" style="max-height: 9999px;">
                <div class="table-wrap">
                    <table id="tourneyTable">
                        <thead><tr>
                            <th onclick="sortTable('tourneyTable',0)">Date</th>
                            <th onclick="sortTable('tourneyTable',1)">Store</th>
                            <th onclick="sortTable('tourneyTable',2)">Event</th>
                            <th onclick="sortTable('tourneyTable',3)">Result</th>
                            <th onclick="sortTable('tourneyTable',4)">Games</th>
                            <th onclick="sortTable('tourneyTable',5)">Points</th>
                            <th onclick="sortTable('tourneyTable',6)">Rank</th>
                        </tr></thead>
                        <tbody id="tourneyBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="card" id="eventSizeCard" style="display:none">
            <div class="card-header" onclick="toggleCard('eventsize')">
                <h2><span class="section-icon">&#128081;</span> Performance by Event Size</h2>
                <span class="toggle-icon" id="eventsize-icon">▼</span>
            </div>
            <div class="card-body" id="eventsize-body" style="max-height:9999px;">
                <div class="table-wrap">
                    <table id="eventSizeTable">
                        <thead><tr>
                            <th onclick="sortTable('eventSizeTable',0)">Event Size</th>
                            <th onclick="sortTable('eventSizeTable',1)">W</th>
                            <th onclick="sortTable('eventSizeTable',2)">L</th>
                            <th onclick="sortTable('eventSizeTable',3)">Total</th>
                            <th onclick="sortTable('eventSizeTable',4)">Win%</th>
                        </tr></thead>
                        <tbody id="eventSizeBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="card" id="roundCard" style="display:none">
            <div class="card-header" onclick="toggleCard('rounds')">
                <h2><span class="section-icon">&#9876;&#65039;</span> Round by Round</h2>
                <span class="toggle-icon" id="rounds-icon">▼</span>
            </div>
            <div class="card-body" id="rounds-body" style="max-height:9999px;">
                <div class="chart-panel" style="margin-bottom:1.5rem;">
                    <h3>Win % by Round</h3>
                    <p style="font-size:0.78rem;color:var(--muted);margin:-0.25rem 0 0.75rem;">Win percentage for each round slot across all tournaments. Reveals if performance drops in later rounds.</p>
                    <div class="chart-canvas-wrap">
                        <canvas id="chartRoundBar"></canvas>
                    </div>
                </div>
                <div class="table-wrap">
                    <table id="roundTable">
                        <thead><tr>
                            <th onclick="sortTable('roundTable',0)">Round</th>
                            <th onclick="sortTable('roundTable',1)">W</th>
                            <th onclick="sortTable('roundTable',2)">L</th>
                            <th onclick="sortTable('roundTable',3)">Total</th>
                            <th onclick="sortTable('roundTable',4)">Win%</th>
                        </tr></thead>
                        <tbody id="roundBody"></tbody>
                    </table>
                </div>

                <div id="roundOppSection" style="margin-top:1.5rem; display:none;">
                    <h3 style="font-size:0.78rem;text-transform:uppercase;letter-spacing:0.06em;color:var(--muted);font-weight:600;margin-bottom:0.75rem;">Most Faced Opponent per Round</h3>
                    <div id="roundOppGrid" style="display:grid;grid-template-columns:repeat(5,1fr);gap:0.75rem;"></div>
                </div>
            </div>
        </div>

        <!-- Round-by-Round Heatmap -->
        <div class="card" id="heatmapCard" style="display:none">
            <div class="card-header" onclick="toggleCard('heatmap')">
                <h2><span class="section-icon">&#128200;</span> Round-by-Round Heatmap</h2>
                <span class="toggle-icon" id="heatmap-icon">&#9660;</span>
            </div>
            <div class="card-body" id="heatmap-body" style="max-height:9999px;">
                <p style="font-size:0.78rem;color:var(--muted);margin-bottom:1rem;">Each row is one event. Each cell is one round. Green = win, red = loss, gray = not played. Win % per round shown at the bottom.</p>
                <div id="heatmapGrid" style="max-height:400px;overflow-y:auto;overflow-x:auto;"></div>
            </div>
        </div>

        <!-- Recurring Opponents -->
        <div class="card" id="recurringCard" style="display:none">
            <div class="card-header" onclick="toggleCard('recurring')">
                <h2><span class="section-icon">&#128257;</span> Recurring Opponents</h2>
                <span class="toggle-icon" id="recurring-icon">&#9660;</span>
            </div>
            <div class="card-body" id="recurring-body" style="max-height:9999px;">
                <p style="font-size:0.78rem;color:var(--muted);margin-bottom:1rem;">Opponents faced in more than one distinct event.</p>
                <div class="table-wrap">
                    <table id="recurringTable">
                        <thead><tr>
                            <th onclick="sortTable('recurringTable',0)">Player</th>
                            <th onclick="sortTable('recurringTable',1)">Events Faced</th>
                            <th onclick="sortTable('recurringTable',2)">W</th>
                            <th onclick="sortTable('recurringTable',3)">L</th>
                            <th onclick="sortTable('recurringTable',4)">Win%</th>
                            <th onclick="sortTable('recurringTable',5)">First Met</th>
                            <th onclick="sortTable('recurringTable',6)">Last Met</th>
                        </tr></thead>
                        <tbody id="recurringBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Store Performance -->
        <div class="card" id="storeBreakCard" style="display:none">
            <div class="card-header" onclick="toggleCard('storeBreak')">
                <h2><span class="section-icon">&#127981;</span> Store Performance</h2>
                <span class="toggle-icon" id="storeBreak-icon">&#9660;</span>
            </div>
            <div class="card-body" id="storeBreak-body" style="max-height:9999px;">
                <div class="table-wrap">
                    <table id="storeBreakTable">
                        <thead><tr>
                            <th onclick="sortTable('storeBreakTable',0)">Store</th>
                            <th onclick="sortTable('storeBreakTable',1)">Events</th>
                            <th onclick="sortTable('storeBreakTable',2)">W</th>
                            <th onclick="sortTable('storeBreakTable',3)">L</th>
                            <th onclick="sortTable('storeBreakTable',4)">Win%</th>
                        </tr></thead>
                        <tbody id="storeBreakBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Seasonality Polar Chart -->
        <div class="card" id="seasonalityCard" style="display:none">
            <div class="card-header" onclick="toggleCard('seasonality')">
                <h2><span class="section-icon">&#127758;</span> Win Rate by Month of Year</h2>
                <span class="toggle-icon" id="seasonality-icon">&#9660;</span>
            </div>
            <div class="card-body" id="seasonality-body" style="max-height:9999px;">
                <p style="font-size:0.78rem;color:var(--muted);margin-bottom:1rem;">Average win % for each calendar month across all years.</p>
                <div class="chart-canvas-wrap" style="max-width:400px;margin:0 auto;">
                    <canvas id="chartSeasonality"></canvas>
                </div>
            </div>
        </div>

        <!-- Personal Bests -->
        <div class="card" id="personalBestsCard" style="display:none">
            <div class="card-header" onclick="toggleCard('personalBests')">
                <h2><span class="section-icon">&#127942;</span> Personal Bests</h2>
                <span class="toggle-icon" id="personalBests-icon">&#9660;</span>
            </div>
            <div class="card-body" id="personalBests-body" style="max-height:9999px;">
                <div class="stat-grid" id="personalBestsGrid"></div>
            </div>
        </div>

        <div class="card" id="regionalsCard" style="display:none">
            <div class="card-header" onclick="toggleCard('regionals')">
                <h2><span class="section-icon">&#127942;</span> Regionals</h2>
                <span class="toggle-icon" id="regionals-icon">▼</span>
            </div>
            <div class="card-body" id="regionals-body" style="max-height: 9999px;">
                <div class="chart-panel" id="regionalScatterPanel" style="margin-bottom:1.5rem;display:none;">
                    <h3>Tournament Size vs. Result</h3>
                    <p style="font-size:0.78rem;color:var(--muted);margin:-0.25rem 0 0.75rem;">Each dot is a regional event. X = number of applicants, Y = win % achieved. Larger events to the right.</p>
                    <div class="chart-canvas-wrap">
                        <canvas id="chartRegionalScatter"></canvas>
                    </div>
                </div>
                <div class="table-wrap">
                    <table id="regionalsTable">
                        <thead><tr>
                            <th onclick="sortTable('regionalsTable',0)">Date</th>
                            <th onclick="sortTable('regionalsTable',1)">Event</th>
                            <th onclick="sortTable('regionalsTable',2)">Result</th>
                        </tr></thead>
                        <tbody id="regionalsBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header row-flex" onclick="toggleCard('players')">
                <h2><span class="section-icon">&#9876;&#65039;</span> Results by Player</h2>
                <div style="display:flex;align-items:center;gap:0.5rem;">
                    <button class="btn btn-outline btn-sm" onclick="event.stopPropagation();exportExcel()">&#8675; Export Excel</button>
                    <span class="toggle-icon" id="players-icon">▼</span>
                </div>
            </div>
            <div class="card-body" id="players-body" style="max-height: 9999px;">

            <!-- Top Opponents chart -->
            <div class="chart-panel" style="margin-bottom:1.5rem;">
                <h3>Top 10 Opponents</h3>
                <p style="font-size:0.78rem;color:var(--muted);margin:-0.25rem 0 0.75rem;">Most-faced opponents by total matches. <span style="color:var(--win);">&#9632;</span> Wins &nbsp;<span style="color:#dc3545;">&#9632;</span> Losses.</p>
                <div class="chart-canvas-wrap tall">
                    <canvas id="chartTopOpponents"></canvas>
                </div>
            </div>

            <!-- Player search -->
            <div style="margin-bottom:1rem;">
                <label for="playerSearchInput">Filter by player</label>
                <div class="player-search-wrap">
                    <input type="text" id="playerSearchInput" placeholder="Type a player name…"
                        autocomplete="off"
                        oninput="onPlayerSearchInput()"
                        onkeydown="onPlayerSearchKey(event)"
                        onfocus="showAutocomplete()"
                        onblur="hideAutocomplete()">
                    <ul class="player-autocomplete" id="playerAutocomplete"></ul>
                </div>
            </div>

            <!-- vs banner (shown when a player is selected) -->
            <div class="vs-banner" id="vsBanner">
                vs <strong id="vsName"></strong>:
                <span id="vsStats"></span>
                <button class="btn btn-outline btn-sm btn-clear" onclick="clearPlayerFilter()">&#10005; Show all</button>
            </div>

            <div class="table-wrap">
                <table id="playerTable">
                    <thead><tr>
                        <th onclick="sortTable('playerTable',0)">Player</th>
                        <th onclick="sortTable('playerTable',1)">W</th>
                        <th onclick="sortTable('playerTable',2)">L</th>
                        <th onclick="sortTable('playerTable',3)">Total</th>
                        <th onclick="sortTable('playerTable',4)">Win%</th>
                        <th onclick="sortTable('playerTable',5)">Events</th>
                    </tr></thead>
                    <tbody id="playerBody"></tbody>
                </table>
            </div>
            </div>
        </div>

<div class="card" id="compareCard" style="display:none">
            <div class="card-header" onclick="toggleCard('compare')">
                <h2><span class="section-icon">&#9760;&#65039;</span> Multi-user Comparison</h2>
                <span class="toggle-icon" id="compare-icon">▼</span>
            </div>
            <div class="card-body" id="compare-body" style="max-height:9999px;">
                <div class="filter-row" style="margin-top:0;margin-bottom:1.25rem;">
                    <div class="filter-group" style="flex:1;min-width:180px;">
                        <label for="compareUserSelect">Compare with</label>
                        <select id="compareUserSelect" onchange="onCompareUserChange()">
                            <option value="">— select a user —</option>
                        </select>
                    </div>
                </div>
                <div id="compareContent"></div>
            </div>
        </div>

    </div>

    <!-- Global Rankings Tab -->
    <div id="rankingsTab" style="display:none">

        <!-- Rankings Filters -->
        <div class="card" id="rankFilterCard">
            <div class="card-header" onclick="toggleCard('rankFilters')">
                <h2><span class="section-icon">&#9874;&#65039;</span> Filters</h2>
                <span class="toggle-icon" id="rankFilters-icon">&#9660;</span>
            </div>
            <div class="card-body" id="rankFilters-body" style="max-height:9999px;">
                <!-- Collection chips -->
                <div class="chip-row" id="rankPeriodChips"></div>

                <!-- Year chips -->
                <div class="filter-row" style="margin-top:1rem;">
                    <div class="chip-row" id="rankYearChips">
                        <button class="chip active" data-year="2024" onclick="onRankYearChip(this)">2024</button>
                        <button class="chip active" data-year="2025" onclick="onRankYearChip(this)">2025</button>
                        <button class="chip active" data-year="2026" onclick="onRankYearChip(this)">2026</button>
                    </div>
                </div>

                <!-- Date range presets -->
                <div class="filter-row" style="margin-top:1rem;align-items:center;flex-wrap:wrap;gap:0.5rem;">
                    <span style="font-size:0.75rem;font-weight:600;color:var(--muted);text-transform:uppercase;letter-spacing:0.06em;white-space:nowrap;">Date Range</span>
                    <div class="chip-row" id="rankDatePresetChips" style="flex-wrap:wrap;">
                        <button class="chip active" data-preset="all"      onclick="onRankDatePreset(this)">All Time</button>
                        <button class="chip"        data-preset="7d"       onclick="onRankDatePreset(this)">Last 7 days</button>
                        <button class="chip"        data-preset="30d"      onclick="onRankDatePreset(this)">Last 30 days</button>
                        <button class="chip"        data-preset="90d"      onclick="onRankDatePreset(this)">Last 3 months</button>
                        <button class="chip"        data-preset="this-month"  onclick="onRankDatePreset(this)">This month</button>
                        <button class="chip"        data-preset="last-month"  onclick="onRankDatePreset(this)">Last month</button>
                        <button class="chip"        data-preset="this-year"   onclick="onRankDatePreset(this)">This year</button>
                        <button class="chip"        data-preset="custom"   onclick="onRankDatePreset(this)">Custom&hellip;</button>
                    </div>
                </div>

                <!-- Custom date range (hidden until "Custom" chip selected) -->
                <div id="rankCustomDateRow" style="display:none;margin-top:0.6rem;align-items:center;gap:0.75rem;flex-wrap:wrap;" class="filter-row">
                    <div class="filter-group">
                        <label for="rankDateFrom">From</label>
                        <input type="date" id="rankDateFrom" onchange="applyRankingsFilter()" style="font-size:0.82rem;padding:0.35rem 0.5rem;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);">
                    </div>
                    <div class="filter-group">
                        <label for="rankDateTo">To</label>
                        <input type="date" id="rankDateTo" onchange="applyRankingsFilter()" style="font-size:0.82rem;padding:0.35rem 0.5rem;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);">
                    </div>
                </div>

                <!-- Store filter -->
                <div class="filter-row" style="margin-top:0.75rem;">
                    <div class="filter-group" style="flex:1;min-width:200px;">
                        <label for="rankStoreSelect">Store</label>
                        <select id="rankStoreSelect" onchange="onRankStoreChange()">
                            <option value="">— all stores —</option>
                        </select>
                    </div>
                    <button class="btn btn-outline btn-sm" onclick="clearRankStoreFilter()" style="align-self:flex-end">&#10005; Clear store</button>
                </div>

                <div style="margin-top:0.75rem;">
                    <button class="btn btn-outline btn-sm" onclick="clearRankFilters()">&#10005; Clear all filters</button>
                    <span id="rankFilterSummary" style="margin-left:0.75rem;font-size:0.8rem;color:var(--muted);"></span>
                </div>
            </div>
        </div>

        <!-- A: Overall Leaderboard -->
        <div class="card">
            <div class="card-header" onclick="toggleCard('rankBoard')">
                <h2><span class="section-icon">&#127942;</span> Overall Leaderboard</h2>
                <span class="toggle-icon" id="rankBoard-icon">&#9660;</span>
            </div>
            <div class="card-body" id="rankBoard-body" style="max-height:9999px;">
                <p style="font-size:0.8rem;color:var(--muted);margin-bottom:1rem;">Aggregated across all cached events for each tracked player.</p>
                <div class="podium-sort-bar" id="podiumSortBar">
                    <span style="font-size:0.72rem;font-weight:600;color:var(--muted);text-transform:uppercase;letter-spacing:0.06em;margin-right:0.4rem;">Rank by:</span>
                    <button class="podium-sort-btn active" data-sort="pct"     onclick="setPodiumSort('pct')">Win %</button>
                    <button class="podium-sort-btn"         data-sort="wins"   onclick="setPodiumSort('wins')">Wins</button>
                    <button class="podium-sort-btn"         data-sort="pts"    onclick="setPodiumSort('pts')">Match Pts</button>
                    <button class="podium-sort-btn"         data-sort="avgRank" onclick="setPodiumSort('avgRank')">Avg Rank</button>
                </div>
                <div id="podium" style="margin-bottom:2rem;"></div>
                <div class="table-wrap">
                    <table id="leaderboardTable">
                        <thead><tr>
                            <th onclick="sortTable('leaderboardTable',0)">#</th>
                            <th onclick="sortTable('leaderboardTable',1)">Player</th>
                            <th onclick="sortTable('leaderboardTable',2)">W</th>
                            <th onclick="sortTable('leaderboardTable',3)">L</th>
                            <th onclick="sortTable('leaderboardTable',4)">Win%</th>
                            <th onclick="sortTable('leaderboardTable',5)">Tournaments</th>
                            <th onclick="sortTable('leaderboardTable',6)">Avg Rank</th>
                            <th onclick="sortTable('leaderboardTable',7)">Best Rank</th>
                            <th onclick="sortTable('leaderboardTable',8)">Match Pts</th>
                        </tr></thead>
                        <tbody id="leaderboardBody"></tbody>
                    </table>
                </div>
            </div>
        </div>


        <!-- C: Head-to-Head Matrix -->
        <div class="card">
            <div class="card-header" onclick="toggleCard('rankH2H')">
                <h2><span class="section-icon">&#9876;&#65039;</span> Head-to-Head Matrix</h2>
                <span class="toggle-icon" id="rankH2H-icon">&#9660;</span>
            </div>
            <div class="card-body" id="rankH2H-body" style="max-height:9999px;">
                <p style="font-size:0.8rem;color:var(--muted);margin-bottom:1rem;">Win / Loss record between each pair of tracked players. Read row vs column.</p>
                <div class="table-wrap" id="rankH2H"></div>
            </div>
        </div>

        <!-- D: Most Faced Opponents (Community) -->
        <div class="card" id="communityOppCard" style="display:none">
            <div class="card-header" onclick="toggleCard('communityOpp')">
                <h2><span class="section-icon">&#127758;</span> Most Faced Opponents</h2>
                <span class="toggle-icon" id="communityOpp-icon">&#9660;</span>
            </div>
            <div class="card-body" id="communityOpp-body" style="max-height:9999px;">
                <p style="font-size:0.8rem;color:var(--muted);margin-bottom:1rem;">Opponents who appear most across all tracked players' histories combined (excluding tracked players).</p>
                <div class="table-wrap">
                    <table id="communityOppTable">
                        <thead><tr>
                            <th onclick="sortTable('communityOppTable',0)">Opponent</th>
                            <th onclick="sortTable('communityOppTable',1)">Total Matches</th>
                            <th onclick="sortTable('communityOppTable',2)">Faced by N Players</th>
                        </tr></thead>
                        <tbody id="communityOppBody"></tbody>
                    </table>
                </div>
            </div>
        </div>


    </div>

</div>

<!-- Opponent profile modal -->
<div class="modal-overlay" id="opponentModal" onclick="closeOpponentModal(event)">
    <div class="modal-box">
        <button class="modal-close" onclick="document.getElementById('opponentModal').classList.remove('open')">&#10005;</button>
        <div class="modal-title" id="modalPlayerName"></div>
        <div class="modal-sub" id="modalPlayerRecord"></div>
        <div class="modal-section">
            <h3>Match History</h3>
            <div class="table-wrap">
                <table id="modalMatchTable">
                    <thead><tr>
                        <th>Date</th>
                        <th>Event</th>
                        <th>Result</th>
                        <th>Games</th>
                    </tr></thead>
                    <tbody id="modalMatchBody"></tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script>
const SET_PERIODS = [
    { name: "Pre OP-01",                              date: null },
    { name: "OP-01 · Romance Dawn",                   date: new Date("2022-12-02") },
    { name: "OP-02 · Paramount War",                  date: new Date("2023-03-10") },
    { name: "OP-03 · Pillars of Strength",            date: new Date("2023-06-02") },
    { name: "OP-04 · Kingdoms of Intrigue",           date: new Date("2023-09-01") },
    { name: "OP-05 · Awakening of the New Era",       date: new Date("2023-11-03") },
    { name: "OP-06 · Wings of the Captain",           date: new Date("2024-02-23") },
    { name: "OP-07 · 500 Years in the Future",        date: new Date("2024-06-28") },
    { name: "OP-08 · Two Legends",                    date: new Date("2024-09-13") },
    { name: "OP-09 · Emperors in the New World",      date: new Date("2024-12-13") },
    { name: "OP-10 · Royal Blood",                    date: new Date("2025-03-21") },
    { name: "OP-11 · A Fist of Divine Speed",         date: new Date("2025-06-06") },
    { name: "OP-12 · Legacy of the Master",           date: new Date("2025-08-22") },
    { name: "OP-13 · Carrying On His Will",           date: new Date("2025-11-07") },
    { name: "OP-14 / EB-04 · The Azure Sea's Seven",  date: new Date("2026-01-16") },
];

const REGIONALS = [
    { date: "2025-08-02", name: "One Piece Offline Regionals 02/05 - Day 1" },
    { date: "2025-08-03", name: "One Piece Offline Regionals 02/05 - Day 2" },
    { date: "2025-11-08", name: "Latam TCG One Piece Regional - Brazil" },
    { date: "2025-11-09", name: "Offline Treasure Cup - Brazil Day 2" },
];

// State
let _usersWithToken    = []; // { name, bandaiId, token }
let _usernameMap       = {}; // bandaiId → name  (all entries, with or without token)
let _playerResults     = null;
let _allEventData      = [];
let _selectedPlayerId  = null; // bandai id of the player being filtered, or null
let _acHighlight       = -1;   // autocomplete keyboard highlight index
let _selectedStore          = null;  // store name filter, or null
let _regionalsOnly          = false; // when true, show only regional events
let _opponentMatchHistory   = {};    // pid -> [{dateStr, evName, w, l}]

function toggleCard(cardId) {
    const body = document.getElementById(cardId + '-body');
    const icon = document.getElementById(cardId + '-icon');
    if (!body) return;
    body.classList.toggle('collapsed');
    if (icon) icon.style.transform = body.classList.contains('collapsed') ? 'rotate(-90deg)' : '';
}

// ── File / parse ───────────────────────────────────────────────────────────

function parseMapText(text) {
    const users = [];
    const nameMap = {};

    for (const line of text.split('\n')) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Split only on the first two colons so the JWT (which has no colons) is safe
        // Format: Name:BandaiID  OR  Name:BandaiID:BearerToken
        const firstColon  = trimmed.indexOf(':');
        if (firstColon === -1) continue;
        const secondColon = trimmed.indexOf(':', firstColon + 1);

        const name     = trimmed.slice(0, firstColon).trim();
        const bandaiId = secondColon === -1
            ? trimmed.slice(firstColon + 1).trim()
            : trimmed.slice(firstColon + 1, secondColon).trim();
        const token    = secondColon !== -1 ? trimmed.slice(secondColon + 1).trim() : null;

        if (!name || !bandaiId) continue;
        nameMap[bandaiId] = name;
        if (token) users.push({ name, bandaiId, token });
    }

    return { users, nameMap };
}

function applyParsed({ users, nameMap }) {
    _usersWithToken = users;
    _usernameMap    = nameMap;

    const select = document.getElementById('userSelect');
    const status = document.getElementById('fileStatus');

    if (users.length === 0) {
        select.innerHTML = '<option value="">— no users with bearer tokens found —</option>';
        select.disabled = true;
        status.className = 'file-status warn';
        status.textContent = `${Object.keys(nameMap).length} players loaded — add a token to a user entry to enable fetching`;
        document.getElementById('fetchBtn').disabled = true;
        return;
    }

    select.innerHTML = '<option value="">— select a user —</option>';
    for (let i = 0; i < users.length; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = users[i].name;
        select.appendChild(opt);
    }
    if (users.length === 1) select.selectedIndex = 1;
    select.disabled = false;

    const total = Object.keys(nameMap).length;
    status.className = 'file-status ok';
    status.textContent = `${total} players loaded — ${users.length} with token`;

    document.getElementById('syncAllBtn').disabled = users.length < 2;

    onUserChange();
}

function loadMapFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        document.getElementById('usernameMap').value = e.target.result;
        applyParsed(parseMapText(e.target.result));
        const status = document.getElementById('fileStatus');
        status.textContent = status.textContent.replace('loaded', `loaded · ${file.name}`);
    };
    reader.readAsText(file);
}

function parsePasted() {
    const text = document.getElementById('usernameMap').value;
    applyParsed(parseMapText(text));
}

function onUserChange() {
    const idx = document.getElementById('userSelect').value;
    document.getElementById('fetchBtn').disabled = (idx === '');
    if (idx === '') {
        document.getElementById('cacheBar').style.display = 'none';
        return;
    }
    const user = _usersWithToken[parseInt(idx)];
    updateCacheBar(user.bandaiId);
}

// ── Cache (localStorage, keyed per Bandai ID) ──────────────────────────────

const CACHE_PREFIX = 'bandai_events_';

function cacheKey(bandaiId) { return CACHE_PREFIX + bandaiId; }

function loadCache(bandaiId) {
    try {
        const raw = localStorage.getItem(cacheKey(bandaiId));
        return raw ? JSON.parse(raw) : {};
    } catch { return {}; }
}

function saveCache(bandaiId, cache) {
    try {
        localStorage.setItem(cacheKey(bandaiId), JSON.stringify(cache));
    } catch (e) {
        console.warn('localStorage write failed — cache not saved:', e);
    }
}

function clearCacheForUser(bandaiId) {
    localStorage.removeItem(cacheKey(bandaiId));
}

function updateCacheBar(bandaiId) {
    const cache   = loadCache(bandaiId);
    const count   = Object.keys(cache).length;
    const bar     = document.getElementById('cacheBar');
    const inner   = document.getElementById('cacheBarInner');
    const text    = document.getElementById('cacheBarText');
    bar.style.display = '';
    if (count === 0) {
        inner.className = 'cache-bar';
        text.innerHTML  = 'No cached data yet — first run will fetch everything.';
    } else {
        inner.className = 'cache-bar has-cache';
        text.innerHTML  = `<strong>${count}</strong> events cached locally.`;
    }
}

function confirmClearCache() {
    const idx  = document.getElementById('userSelect').value;
    if (idx === '') return;
    const user = _usersWithToken[parseInt(idx)];
    if (!confirm(`Clear all cached events for ${user.name}?\nNext run will re-fetch everything from the API.`)) return;
    clearCacheForUser(user.bandaiId);
    updateCacheBar(user.bandaiId);
}

// Called by "Sync new events only" — just runs fetchAndAnalyze (cache is automatic)
function refreshCache() { fetchAndAnalyze(); }

// ── Helpers ────────────────────────────────────────────────────────────────

// Format a YYYY-MM-DD (or ISO datetime) string as DD/MM/YYYY
function fmtDate(dateStr) {
    if (!dateStr || dateStr === '—') return '—';
    const part = dateStr.slice(0, 10); // works for both 'YYYY-MM-DD' and full ISO
    const [y, m, d] = part.split('-');
    return `${d}/${m}/${y}`;
}

function getPeriodForDate(dateStr) {
    const d = new Date(dateStr);
    let period = SET_PERIODS[0].name;
    for (let i = 1; i < SET_PERIODS.length; i++) {
        if (d >= SET_PERIODS[i].date) period = SET_PERIODS[i].name;
        else break;
    }
    return period;
}

function setProgress(text, pct) {
    document.getElementById('progressText').textContent = text;
    document.getElementById('progressBar').style.width = pct + '%';
}

function showError(html) {
    const box = document.getElementById('errorBox');
    box.innerHTML = `<div class="error-box">${html}</div>`;
    box.style.display = 'block';
}

function clearError() {
    const box = document.getElementById('errorBox');
    box.style.display = 'none';
    box.innerHTML = '';
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ── Fetch & Analyze ────────────────────────────────────────────────────────

// Core fetch+cache logic for a single user. Returns { newCount, totalCount }.
// onProgress(text, pct) is called to update the shared progress bar.
async function fetchUserEvents(user, onProgress) {
    const token = user.token;
    const listUrl = 'https://api.bandai-tcg-plus.com/api/user/my/event'
        + '?favorite=0&game_title_id=&limit=1000&offset=0&past_event_display_flg=1&selected_tab=3';

    const listResp = await fetch(listUrl, { headers: { 'X-Authentication': token } });
    if (!listResp.ok) throw new Error(`Event list failed for ${user.name} (HTTP ${listResp.status})`);
    const events = (await listResp.json()).success.events;

    const cache       = loadCache(user.bandaiId);
    const newEvents   = events.filter(ev => !cache[String(ev.id)]);
    const cachedCount = events.length - newEvents.length;

    // Patch metadata on cached entries
    for (const ev of events) {
        if (cache[String(ev.id)]) {
            const entry = cache[String(ev.id)];
            entry._start_datetime  = ev.start_datetime;
            entry._event_name      = ev.name ?? ev.event_name ?? ev.title
                ?? entry.event?.series_title ?? null;
            entry._store_name      = ev.organizer_name ?? ev.organizer ?? ev.organization_name
                ?? ev.hosted_by ?? ev.store_name ?? ev.shop_name ?? ev.venue_name
                ?? ev.store?.name ?? ev.shop?.name ?? ev.organizer?.name ?? null;
            entry._applicant_count = ev.joinedCount ?? ev.joined_count
                ?? ev.countApplicants ?? ev.numberOfPeople
                ?? ev.aplicantes ?? ev.aplicants
                ?? ev.entry_count ?? ev.applicant_count
                ?? ev.participant_count ?? ev.entries ?? null;
            entry._capacity        = ev.capacity ?? ev.max_capacity ?? ev.max_entry_count ?? null;
            if (entry._rank == null && entry.user?.rank != null)
                entry._rank = entry.user.rank;
            if (entry._match_points == null && entry.user?.match_point != null)
                entry._match_points = Number(entry.user.match_point);
        }
    }

    if (newEvents.length > 0) {
        for (let i = 0; i < newEvents.length; i++) {
            const ev = newEvents[i];
            onProgress(
                `${user.name}: fetching ${i + 1}/${newEvents.length} new events (${cachedCount} cached)…`,
                Math.round((i / newEvents.length) * 100)
            );
            const evResp = await fetch(
                `https://api.bandai-tcg-plus.com/api/user/event/${ev.id}/history`,
                { headers: { 'X-Authentication': token } }
            );
            if (evResp.ok) {
                const evData = (await evResp.json()).success;
                evData._start_datetime  = ev.start_datetime;
                evData._event_name      = ev.name ?? ev.event_name ?? ev.title
                    ?? evData.event?.name ?? evData.event?.event_name
                    ?? evData.event?.series_title ?? null;
                evData._rank            = evData.user?.rank ?? null;
                evData._match_points    = evData.user?.match_point != null
                    ? Number(evData.user.match_point) : null;
                evData._store_name      = ev.organizer_name ?? ev.organizer ?? ev.organization_name
                    ?? ev.hosted_by ?? ev.store_name ?? ev.shop_name ?? ev.venue_name
                    ?? ev.store?.name ?? ev.shop?.name ?? ev.organizer?.name
                    ?? evData.event?.organizer_name ?? evData.event?.organizer
                    ?? evData.event?.organization_name ?? evData.event?.hosted_by
                    ?? evData.event?.store_name ?? evData.event?.shop_name
                    ?? evData.event?.venue_name ?? evData.event?.store?.name
                    ?? evData.event?.organizer?.name ?? null;
                evData._applicant_count = ev.joinedCount ?? ev.joined_count
                    ?? ev.countApplicants ?? ev.numberOfPeople
                    ?? ev.aplicantes ?? ev.aplicants
                    ?? ev.entry_count ?? ev.applicant_count
                    ?? ev.participant_count ?? ev.entries
                    ?? evData.event?.joinedCount ?? evData.event?.joined_count
                    ?? evData.event?.countApplicants ?? evData.event?.numberOfPeople
                    ?? evData.event?.aplicantes ?? evData.event?.aplicants
                    ?? evData.event?.entry_count ?? evData.event?.applicant_count
                    ?? evData.event?.participant_count ?? null;
                evData._capacity        = ev.capacity ?? ev.max_capacity
                    ?? ev.max_entry_count
                    ?? evData.event?.capacity ?? evData.event?.max_capacity ?? null;
                cache[String(ev.id)] = evData;
            }
            await sleep(300);
        }
    }

    // Always save — metadata patches (rank, points, applicant count) are applied
    // to cached entries regardless of whether new events were fetched.
    saveCache(user.bandaiId, cache);

    return { newCount: newEvents.length, totalCount: events.length };
}

// Sync new events for every user with a token, then re-render the currently selected user.
async function syncAllUsers() {
    if (_usersWithToken.length === 0) return;

    clearError();
    document.getElementById('progress').style.display = 'block';
    document.getElementById('fetchBtn').disabled  = true;
    document.getElementById('syncAllBtn').disabled = true;

    const results = []; // { name, newCount, totalCount, error }

    try {
        for (let u = 0; u < _usersWithToken.length; u++) {
            const user = _usersWithToken[u];
            const pctBase = Math.round((u / _usersWithToken.length) * 90);
            const pctNext = Math.round(((u + 1) / _usersWithToken.length) * 90);
            setProgress(`Syncing ${u + 1}/${_usersWithToken.length}: ${user.name}…`, pctBase);
            try {
                const { newCount, totalCount } = await fetchUserEvents(user, (text, pct) => {
                    const scaled = pctBase + Math.round(pct / 100 * (pctNext - pctBase));
                    setProgress(text, scaled);
                });
                results.push({ name: user.name, newCount, totalCount, error: null });
            } catch (err) {
                results.push({ name: user.name, newCount: 0, totalCount: 0, error: err.message });
            }
            updateCacheBar(_usersWithToken[parseInt(document.getElementById('userSelect').value || '0')]?.bandaiId);
        }

        setProgress('All users synced!', 100);
        setTimeout(() => { document.getElementById('progress').style.display = 'none'; }, 800);

        // Show a brief summary
        const lines = results.map(r =>
            r.error
                ? `${r.name}: ❌ ${r.error}`
                : `${r.name}: +${r.newCount} new (${r.totalCount} total)`
        ).join('\n');
        console.log('[Sync All]\n' + lines);

        // Re-render the currently selected user if one is active
        const selIdx = document.getElementById('userSelect').value;
        if (selIdx !== '') {
            const user = _usersWithToken[parseInt(selIdx)];
            const cache = loadCache(user.bandaiId);
            const allEventData = Object.values(cache).sort((a, b) =>
                new Date(b._start_datetime) - new Date(a._start_datetime));
            _allEventData = allEventData;
            updateCacheBar(user.bandaiId);

            let totalW = 0, totalL = 0;
            for (const ev of allEventData) {
                if (!ev?.rounds) continue;
                for (const r of ev.rounds) { if (r.is_win) totalW++; else totalL++; }
            }
            const periodMap = {};
            for (const p of SET_PERIODS) periodMap[p.name] = { w: 0, l: 0 };
            for (const ev of allEventData) {
                if (!ev?.rounds) continue;
                const period = ev._start_datetime
                    ? getPeriodForDate(ev._start_datetime) : SET_PERIODS[0].name;
                for (const r of ev.rounds) {
                    if (r.is_win) periodMap[period].w++; else periodMap[period].l++;
                }
            }
            const playerMap = {};
            for (const ev of allEventData) {
                if (!ev?.rounds) continue;
                for (const r of ev.rounds) {
                    const pid = r.opponent_users?.[0]?.membership_number;
                    if (!pid) continue;
                    if (!playerMap[pid]) playerMap[pid] = [0, 0];
                    if (r.is_win) playerMap[pid][0]++; else playerMap[pid][1]++;
                }
            }
            _playerResults = playerMap;

            buildFilterChips(allEventData);
            buildStoreFilter(allEventData);
            buildCompareCard();
            displayResults(user.name, totalW, totalL, periodMap, playerMap, allEventData);
        }

        // Show the tab nav and refresh rankings if visible
        document.getElementById('tabNav').style.display = 'flex';
        if (document.getElementById('rankingsTab').style.display !== 'none') buildGlobalRankings();

        // Show summary in a status line under the buttons
        const summaryEl = document.getElementById('syncAllSummary');
        if (summaryEl) {
            const newTotal = results.reduce((s, r) => s + r.newCount, 0);
            const errCount = results.filter(r => r.error).length;
            summaryEl.textContent = errCount
                ? `Sync complete — ${newTotal} new events across ${results.length} users (${errCount} error${errCount>1?'s':''})`
                : `Sync complete — ${newTotal} new event${newTotal !== 1 ? 's' : ''} across ${results.length} users`;
            summaryEl.style.display = '';
        }

    } catch (err) {
        showError(err.message);
    } finally {
        document.getElementById('fetchBtn').disabled  = false;
        document.getElementById('syncAllBtn').disabled = _usersWithToken.length < 2;
    }
}

async function fetchAndAnalyze() {
    const idx = document.getElementById('userSelect').value;
    if (idx === '') { showError('Please select a user.'); return; }

    const user  = _usersWithToken[parseInt(idx)];
    const token = user.token;

    clearError();
    document.getElementById('progress').style.display = 'block';
    document.getElementById('results').style.display  = 'none';
    document.getElementById('fetchBtn').disabled = true;
    document.getElementById('syncAllBtn').disabled = true;

    try {
        // 1 & 2. Fetch + cache new events via shared helper
        setProgress(`Fetching event list for ${user.name}…`, 5);
        await fetchUserEvents(user, (text, pct) => setProgress(text, 5 + Math.round(pct / 100 * 90)));

        // 3. Build full dataset from cache in event-list order
        const cache = loadCache(user.bandaiId);
        const allEventData = Object.values(cache).sort(
            (a, b) => new Date(b._start_datetime) - new Date(a._start_datetime));
        _allEventData     = allEventData;
        _selectedPlayerId = null;
        _selectedStore    = null;
        _regionalsOnly    = false;
        document.getElementById('playerSearchInput').value = '';
        document.getElementById('vsBanner').style.display  = 'none';
        document.getElementById('dateFrom').value = '';
        document.getElementById('dateTo').value   = '';
        document.getElementById('regionalsOnlyBtn').classList.remove('active');

        updateCacheBar(user.bandaiId);
        setProgress('Processing data…', 97);

        // 3. Overall W/L
        let totalW = 0, totalL = 0;
        for (const ev of allEventData) {
            if (!ev?.rounds) continue;
            for (const r of ev.rounds) { if (r.is_win) totalW++; else totalL++; }
        }

        // 4. By period
        const periodMap = {};
        for (const p of SET_PERIODS) periodMap[p.name] = { w: 0, l: 0 };
        for (const ev of allEventData) {
            if (!ev?.rounds) continue;
            const period = ev._start_datetime
                ? getPeriodForDate(ev._start_datetime) : SET_PERIODS[0].name;
            for (const r of ev.rounds) {
                if (r.is_win) periodMap[period].w++; else periodMap[period].l++;
            }
        }

        // 5. By player
        const playerMap = {};
        for (const ev of allEventData) {
            if (!ev?.rounds) continue;
            for (const r of ev.rounds) {
                const pid = r.opponent_users?.[0]?.membership_number;
                if (!pid) continue;
                if (!playerMap[pid]) playerMap[pid] = [0, 0];
                if (r.is_win) playerMap[pid][0]++; else playerMap[pid][1]++;
            }
        }
        _playerResults = playerMap;

        setProgress('Done!', 100);
        setTimeout(() => { document.getElementById('progress').style.display = 'none'; }, 600);

        buildFilterChips(allEventData);
        buildStoreFilter(allEventData);
        buildCompareCard();
        displayResults(user.name, totalW, totalL, periodMap, playerMap, allEventData);

        // Show tab nav; if user is already on the rankings tab, refresh it
        document.getElementById('tabNav').style.display = 'flex';
        if (document.getElementById('rankingsTab').style.display !== 'none') buildGlobalRankings();

    } catch (err) {
        document.getElementById('progress').style.display = 'none';
        let msg = err.message;
        if (err instanceof TypeError && err.message.toLowerCase().includes('fetch')) {
            msg = `<strong>Network / CORS error</strong> — the browser blocked the request to the Bandai API.<br><br>
The API is designed for the mobile app and does not include CORS headers.
To bypass this, launch Chrome with web-security disabled:<br><br>
<code>"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe" --disable-web-security --user-data-dir="%TEMP%\\chrome-no-cors"</code><br><br>
Then open <code>analyzer.html</code> in that window.`;
        }
        showError(msg);
    } finally {
        document.getElementById('fetchBtn').disabled = false;
        document.getElementById('syncAllBtn').disabled = _usersWithToken.length < 2;
    }
}

// ── Date filter ────────────────────────────────────────────────────────────

function clearYearChips() {
    document.querySelectorAll('#yearChips .chip').forEach(c => c.classList.remove('active'));
}

function onYearChip(btn) {
    const year     = btn.dataset.year;
    const isActive = btn.classList.contains('active');
    clearYearChips();
    if (isActive) {
        document.getElementById('dateFrom').value = '';
        document.getElementById('dateTo').value   = '';
    } else {
        btn.classList.add('active');
        document.getElementById('dateFrom').value = `${year}-01-01`;
        document.getElementById('dateTo').value   = `${year}-12-31`;
    }
    applyFilter();
}

// When the user edits dates manually, deselect year chips (they may no longer match)
function onDateRangeChange() {
    clearYearChips();
    applyFilter();
}

function clearDateFilter() {
    document.getElementById('dateFrom').value = '';
    document.getElementById('dateTo').value   = '';
    clearYearChips();
    applyFilter();
}

function getDateRange() {
    const from = document.getElementById('dateFrom').value; // 'YYYY-MM-DD' or ''
    const to   = document.getElementById('dateTo').value;
    return {
        from: from ? new Date(from) : null,
        to:   to   ? new Date(to + 'T23:59:59') : null,
    };
}

// ── Store filter ───────────────────────────────────────────────────────────

function buildStoreFilter(allEventData) {
    const stores = new Set();
    for (const ev of allEventData) {
        if (ev._store_name) stores.add(ev._store_name);
    }
    const sel = document.getElementById('storeSelect');
    sel.innerHTML = '<option value="">— all stores —</option>';
    const sorted = [...stores].sort((a, b) => a.localeCompare(b));
    for (const name of sorted) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
    }
    // Restore previous selection if still valid
    if (_selectedStore && stores.has(_selectedStore)) sel.value = _selectedStore;
    else _selectedStore = null;
}

function onStoreChange() {
    const val = document.getElementById('storeSelect').value;
    _selectedStore = val || null;
    applyFilter();
}

function clearStoreFilter() {
    _selectedStore = null;
    document.getElementById('storeSelect').value = '';
    applyFilter();
}

// ── Regionals filter ───────────────────────────────────────────────────────

const _regionalDates = new Set(REGIONALS.map(r => r.date));

function toggleRegionalsOnly() {
    _regionalsOnly = !_regionalsOnly;
    document.getElementById('regionalsOnlyBtn').classList.toggle('active', _regionalsOnly);
    applyFilter();
}

// ── Player filter / autocomplete ───────────────────────────────────────────

function buildPlayerList() {
    // Returns sorted list of { id, name } for players that appear in _allEventData
    const seen = new Map();
    for (const ev of _allEventData) {
        if (!ev?.rounds) continue;
        for (const r of ev.rounds) {
            const pid = r.opponent_users?.[0]?.membership_number;
            if (pid && !seen.has(pid)) seen.set(pid, _usernameMap[pid] || pid);
        }
    }
    return [...seen.entries()]
        .map(([id, name]) => ({ id, name }))
        .sort((a, b) => a.name.localeCompare(b.name));
}

function onPlayerSearchInput() {
    _selectedPlayerId = null;
    _acHighlight = -1;
    const q = document.getElementById('playerSearchInput').value.trim().toLowerCase();
    if (!q) { hideAutocomplete(); return; }
    const matches = buildPlayerList().filter(p => p.name.toLowerCase().includes(q)).slice(0, 20);
    renderAutocomplete(matches);
}

function renderAutocomplete(matches) {
    const ul = document.getElementById('playerAutocomplete');
    ul.innerHTML = '';
    if (matches.length === 0) { ul.style.display = 'none'; return; }
    matches.forEach((p, i) => {
        const li = document.createElement('li');
        li.textContent = p.name;
        li.dataset.pid = p.id;
        li.onmousedown = () => selectPlayer(p.id, p.name); // mousedown fires before blur
        ul.appendChild(li);
    });
    ul.style.display = 'block';
}

function showAutocomplete() {
    const q = document.getElementById('playerSearchInput').value.trim();
    if (q) onPlayerSearchInput();
}

function hideAutocomplete() {
    setTimeout(() => {
        document.getElementById('playerAutocomplete').style.display = 'none';
        _acHighlight = -1;
    }, 150);
}

function onPlayerSearchKey(e) {
    const ul    = document.getElementById('playerAutocomplete');
    const items = [...ul.querySelectorAll('li')];
    if (!items.length) return;

    if (e.key === 'ArrowDown') {
        e.preventDefault();
        _acHighlight = Math.min(_acHighlight + 1, items.length - 1);
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        _acHighlight = Math.max(_acHighlight - 1, 0);
    } else if (e.key === 'Enter') {
        e.preventDefault();
        if (_acHighlight >= 0) {
            const li = items[_acHighlight];
            selectPlayer(li.dataset.pid, li.textContent);
        }
        return;
    } else if (e.key === 'Escape') {
        clearPlayerFilter();
        return;
    }

    items.forEach((li, i) => li.classList.toggle('highlighted', i === _acHighlight));
    if (_acHighlight >= 0) items[_acHighlight].scrollIntoView({ block: 'nearest' });
}

function selectPlayer(pid, name) {
    _selectedPlayerId = pid;
    document.getElementById('playerSearchInput').value = name;
    document.getElementById('playerAutocomplete').style.display = 'none';
    applyFilter();
}

function clearPlayerFilter() {
    _selectedPlayerId = null;
    document.getElementById('playerSearchInput').value = '';
    document.getElementById('vsBanner').style.display = 'none';
    applyFilter();
}

// ── Period filter ──────────────────────────────────────────────────────────

function buildFilterChips(allEventData) {
    // Determine which periods actually have events
    const periodsWithData = new Set();
    for (const ev of allEventData) {
        if (!ev?.rounds) continue;
        const period = ev._start_datetime ? getPeriodForDate(ev._start_datetime) : SET_PERIODS[0].name;
        periodsWithData.add(period);
    }

    const container = document.getElementById('periodChips');
    container.innerHTML = '';

    // "All" chip
    const allChip = document.createElement('button');
    allChip.className = 'chip chip-all active';
    allChip.textContent = 'All';
    allChip.dataset.period = 'all';
    allChip.onclick = () => {
        const indiv = [...container.querySelectorAll('.chip:not(.chip-all)')];
        const allOn = indiv.every(c => c.classList.contains('active'));
        indiv.forEach(c => c.classList.toggle('active', !allOn));
        allChip.classList.toggle('active', !allOn);
        applyFilter();
    };
    container.appendChild(allChip);

    // One chip per period that has data
    for (const p of SET_PERIODS) {
        if (!periodsWithData.has(p.name)) continue;
        const chip = document.createElement('button');
        chip.className = 'chip active';
        chip.textContent = p.name.split(' · ')[0]; // short label
        chip.title = p.name;                        // full name on hover
        chip.dataset.period = p.name;
        chip.onclick = () => {
            chip.classList.toggle('active');
            const indiv = [...container.querySelectorAll('.chip:not(.chip-all)')];
            const allOn = indiv.every(c => c.classList.contains('active'));
            allChip.classList.toggle('active', allOn);
            applyFilter();
        };
        container.appendChild(chip);
    }

    document.getElementById('filterCard').style.display = 'block';
}

function getSelectedPeriods() {
    const chips = document.querySelectorAll('#periodChips .chip:not(.chip-all)');
    return new Set([...chips].filter(c => c.classList.contains('active')).map(c => c.dataset.period));
}

function applyFilter() {
    const selected  = getSelectedPeriods();
    const { from, to } = getDateRange();

    const filtered = _allEventData.filter(ev => {
        if (!ev?.rounds) return false;

        // Period chip filter
        if (selected.size > 0) {
            const period = ev._start_datetime ? getPeriodForDate(ev._start_datetime) : SET_PERIODS[0].name;
            if (!selected.has(period)) return false;
        }

        // Date range filter
        if (ev._start_datetime) {
            const d = new Date(ev._start_datetime);
            if (from && d < from) return false;
            if (to   && d > to)   return false;
        }

        // Store filter
        if (_selectedStore && ev._store_name !== _selectedStore) return false;

        // Regionals-only filter
        if (_regionalsOnly) {
            const d = ev._start_datetime?.slice(0, 10);
            if (!d || !_regionalDates.has(d)) return false;
        }

        return true;
    });

    let totalW = 0, totalL = 0;
    for (const ev of filtered) {
        if (!ev?.rounds) continue;
        for (const r of ev.rounds) { if (r.is_win) totalW++; else totalL++; }
    }

    const periodMap = {};
    for (const p of SET_PERIODS) periodMap[p.name] = { w: 0, l: 0 };
    for (const ev of filtered) {
        if (!ev?.rounds) continue;
        const period = ev._start_datetime ? getPeriodForDate(ev._start_datetime) : SET_PERIODS[0].name;
        for (const r of ev.rounds) { if (r.is_win) periodMap[period].w++; else periodMap[period].l++; }
    }

    const playerMap = {};
    for (const ev of filtered) {
        if (!ev?.rounds) continue;
        for (const r of ev.rounds) {
            const pid = r.opponent_users?.[0]?.membership_number;
            if (!pid) continue;
            if (!playerMap[pid]) playerMap[pid] = [0, 0];
            if (r.is_win) playerMap[pid][0]++; else playerMap[pid][1]++;
        }
    }
    _playerResults = playerMap;

    // Update vs banner when a specific player is selected
    const banner = document.getElementById('vsBanner');
    if (_selectedPlayerId && playerMap[_selectedPlayerId]) {
        const [w, l] = playerMap[_selectedPlayerId];
        const t   = w + l;
        const pct = t > 0 ? (w / t * 100).toFixed(1) : '0.0';
        document.getElementById('vsName').textContent  = _usernameMap[_selectedPlayerId] || _selectedPlayerId;
        document.getElementById('vsStats').innerHTML   = `<span style="color:var(--win)">${w}W</span> / <span style="color:var(--loss)">${l}L</span> — <strong>${pct}%</strong> win rate over ${t} match${t !== 1 ? 'es' : ''}`;
        banner.style.display = 'flex';
    } else if (_selectedPlayerId) {
        document.getElementById('vsName').textContent  = _usernameMap[_selectedPlayerId] || _selectedPlayerId;
        document.getElementById('vsStats').innerHTML   = 'No matches in the selected period';
        banner.style.display = 'flex';
    } else {
        banner.style.display = 'none';
    }

    displayResults('', totalW, totalL, periodMap, playerMap, filtered);
}

// ── Display ────────────────────────────────────────────────────────────────

function displayResults(userName, totalW, totalL, periodMap, playerMap, eventData) {
    const total  = totalW + totalL;
    const winPct = total > 0 ? (totalW / total * 100).toFixed(1) : '0.0';

    document.getElementById('overallStats').innerHTML = `
        <div class="stat-box"><div class="val w-val">${totalW}</div><div class="lbl">Wins</div></div>
        <div class="stat-box"><div class="val l-val">${totalL}</div><div class="lbl">Losses</div></div>
        <div class="stat-box"><div class="val t-val">${total}</div><div class="lbl">Total</div></div>
        <div class="stat-box"><div class="val pct-val">${winPct}%</div><div class="lbl">Win Rate</div></div>`;

    // Rolling form badges appended to the stat grid
    const form = computeRollingForm(eventData);
    const overallFloat = parseFloat(winPct);
    function formBadge(pct, label) {
        if (pct === null) return '';
        const color = pct > overallFloat ? 'var(--win)' : pct < overallFloat ? 'var(--loss)' : 'var(--muted)';
        return `<span style="display:inline-block;font-size:0.7rem;font-weight:700;
            background:${color}22;color:${color};border-radius:999px;
            padding:0.15rem 0.5rem;margin:0.15rem 0.1rem;">L${label}: ${pct.toFixed(1)}%</span>`;
    }
    document.getElementById('overallStats').insertAdjacentHTML('beforeend', `
        <div class="stat-box" style="grid-column:span 2;">
            <div style="font-size:0.65rem;text-transform:uppercase;letter-spacing:0.08em;color:var(--muted);margin-bottom:0.4rem;">Recent Form</div>
            <div>${formBadge(form.last5, '5')}${formBadge(form.last10, '10')}</div>
        </div>`);

    // Game & Clutch stats grid
    const allRounds = (eventData || []).flatMap(ev => ev?.rounds || []);
    const gs = computeGameStats(allRounds);
    const gameTotal = gs.gameWins + gs.gameLosses;
    const gamePct   = gameTotal > 0 ? (gs.gameWins / gameTotal * 100).toFixed(1) : null;
    const twoZeroR  = totalW > 0 ? (gs.twoZeroWins / totalW * 100).toFixed(1) : null;
    const clutchR   = gs.allTwoOne > 0 ? (gs.clutchWins / gs.allTwoOne * 100).toFixed(1) : null;
    const chokeR    = gs.allTwoOne > 0 ? (gs.chokes / gs.allTwoOne * 100).toFixed(1) : null;
    const gameStatsEl = document.getElementById('gameStats');
    if (gameStatsEl) {
        gameStatsEl.innerHTML = `
            <div class="stat-box"><div class="val pct-val">${gamePct !== null ? gamePct + '%' : '—'}</div><div class="lbl">Game Win %</div></div>
            <div class="stat-box"><div class="val pct-val">${twoZeroR !== null ? twoZeroR + '%' : '—'}</div><div class="lbl">2-0 Rate</div></div>
            <div class="stat-box"><div class="val w-val">${clutchR !== null ? clutchR + '%' : '—'}</div><div class="lbl">Clutch Rate</div></div>
            <div class="stat-box"><div class="val l-val">${chokeR !== null ? chokeR + '%' : '—'}</div><div class="lbl">Choke Rate</div></div>`;
    }

    const streaks = computeStreaks(eventData);
    displayStreaks(streaks);

    const periodBody = document.getElementById('periodBody');
    periodBody.innerHTML = '';
    for (const p of SET_PERIODS) {
        const s = periodMap[p.name] || { w: 0, l: 0 };
        if (s.w === 0 && s.l === 0) continue;
        const t   = s.w + s.l;
        const pct = (s.w / t * 100).toFixed(1);
        const tr  = document.createElement('tr');
        tr.innerHTML = `<td>${p.name}</td>
            <td class="td-num">${s.w}</td><td class="td-num">${s.l}</td>
            <td class="td-num">${t}</td><td class="td-pct">${pct}%</td>`;
        periodBody.appendChild(tr);
    }

    // Build per-player event count and match history
    const playerEventsCount = {};
    const opponentHistory   = {};
    for (const ev of (eventData || [])) {
        if (!ev?.rounds) continue;
        const dateStr = ev._start_datetime ? ev._start_datetime.slice(0, 10) : '—';
        const evName  = ev._event_name ?? ev.event?.series_title ?? ev.event?.name ?? '—';
        const seenThisEv = new Set();
        const evOpponents = new Map();
        for (const r of ev.rounds) {
            const pid  = r.opponent_users?.[0]?.membership_number;
            const pName = r.opponent_users?.[0]?.player_name?.trim();
            if (!pid) continue;
            // Enrich username map from round data (always up-to-date)
            if (pName && !_usernameMap[pid]) _usernameMap[pid] = pName;
            if (!seenThisEv.has(pid)) {
                seenThisEv.add(pid);
                playerEventsCount[pid] = (playerEventsCount[pid] || 0) + 1;
            }
            if (!evOpponents.has(pid)) evOpponents.set(pid, { w: 0, l: 0, gw: 0, gl: 0 });
            const opp = evOpponents.get(pid);
            if (r.is_win) opp.w++; else opp.l++;
            // Game-level scores (win_count / lose_count within the match)
            opp.gw += r.win_count  ?? (r.is_win ? 1 : 0);
            opp.gl += r.lose_count ?? (r.is_win ? 0 : 1);
        }
        for (const [pid, res] of evOpponents) {
            if (!opponentHistory[pid]) opponentHistory[pid] = [];
            opponentHistory[pid].push({ dateStr, evName, w: res.w, l: res.l, gw: res.gw, gl: res.gl });
        }
    }
    _opponentMatchHistory = opponentHistory;

    // ── Bogeyman / Victim ───────────────────────────────────────────────────
    displayRivalry(playerMap);

    const playerBody = document.getElementById('playerBody');
    playerBody.innerHTML = '';
    const sorted = Object.entries(playerMap)
        .sort((a, b) => (b[1][0] + b[1][1]) - (a[1][0] + a[1][1]));
    for (const [pid, res] of sorted) {
        const tag = _usernameMap[pid] || pid;
        const [w, l] = res;
        const t   = w + l;
        const pct = (w / t * 100).toFixed(1);
        const evCount = playerEventsCount[pid] || 0;
        const tr  = document.createElement('tr');
        if (pid === _selectedPlayerId) tr.classList.add('row-highlight');
        tr.innerHTML = `<td>${tag}</td>
            <td class="td-num">${w}</td><td class="td-num">${l}</td>
            <td class="td-num">${t}</td><td class="td-pct">${pct}%</td>
            <td class="td-num">${evCount}</td>`;
        tr.style.cursor = 'pointer';
        tr.onclick = () => openOpponentModal(pid);
        playerBody.appendChild(tr);
    }

    // Top Opponents chart
    {
        const TOP_N = 10;
        const topOpp = sorted.slice(0, TOP_N);
        const oppWin  = getComputedStyle(document.documentElement).getPropertyValue('--win').trim()   || '#28a745';
        const oppLoss = getComputedStyle(document.documentElement).getPropertyValue('--loss').trim()  || '#dc3545';
        const oppMuted= getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#6c757d';
        destroyChart('topOpponents');
        _charts['topOpponents'] = new Chart(document.getElementById('chartTopOpponents'), {
            type: 'bar',
            data: {
                labels: topOpp.map(([pid]) => _usernameMap[pid] || pid),
                datasets: [
                    { label: 'Wins',   data: topOpp.map(([,r]) => r[0]), backgroundColor: oppWin  + 'cc', borderRadius: 4 },
                    { label: 'Losses', data: topOpp.map(([,r]) => r[1]), backgroundColor: oppLoss + 'cc', borderRadius: 4 }
                ]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { stacked: true, ticks: { font: { size: 10 }, color: oppMuted }, grid: { color: '#eee' } },
                    y: { stacked: true, ticks: { font: { size: 10 }, color: oppMuted }, grid: { display: false } }
                },
                plugins: {
                    legend: { position: 'bottom', labels: { font: { size: 11 }, color: oppMuted } },
                    tooltip: { callbacks: {
                        afterBody: items => {
                            const [pid] = topOpp[items[0].dataIndex];
                            const [w, l] = playerMap[pid];
                            const t = w + l;
                            return [`Win rate: ${(w / t * 100).toFixed(1)}%  (${t} matches)`];
                        }
                    }}
                }
            }
        });
    }

    // Tournament history table
    if (eventData) {
        const tourneyBody = document.getElementById('tourneyBody');
        tourneyBody.innerHTML = '';
        const evList = [...eventData].reverse(); // newest first

        for (const ev of evList) {
            if (!ev?.rounds) continue;
            let evW = 0, evL = 0, evGW = 0, evGL = 0;
            for (const r of ev.rounds) {
                if (r.is_win) evW++; else evL++;
                evGW += r.win_count  ?? (r.is_win ? 1 : 0);
                evGL += r.lose_count ?? (r.is_win ? 0 : 1);
            }

            const dateStr   = fmtDate(ev._start_datetime);
            const storeName = ev._store_name ?? ev.event?.organizer_name ?? ev.event?.organizer
                ?? ev.event?.store_name ?? ev.event?.shop_name ?? null;
            const storeStr  = storeName ?? '—';
            const evName    = ev._event_name ?? ev.event?.series_title ?? ev.event?.name ?? '—';
            const rankStr   = ev._rank   != null ? `#${ev._rank}`   : '—';
            const ptsStr    = ev._match_points != null ? ev._match_points : '—';
            const resultColor = evW > evL ? 'var(--win)' : evW < evL ? 'var(--loss)' : 'var(--muted)';

            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${dateStr}</td>
                <td>${storeStr}</td>
                <td>${evName}</td>
                <td class="td-num" style="color:${resultColor};font-weight:600">${evW}-${evL}</td>
                <td class="td-num">${evGW}-${evGL}</td>
                <td class="td-num">${ptsStr}</td>
                <td class="td-num">${rankStr}</td>`;
            tourneyBody.appendChild(tr);
        }

    }

    displayMonthly(eventData);
    displayPlacements(eventData);
    displayEventSize(eventData);
    displayRoundByRound(eventData);
    displayRoundHeatmap(eventData);
    displayRegionals(eventData);
    displayCharts(totalW, totalL, periodMap, eventData);
    displayRecurringOpponents(eventData);
    displayStoreBreakdown(eventData);
    displaySeasonality(eventData);
    displayPersonalBests(eventData, streaks);

    document.getElementById('results').style.display = 'block';
}

// ── Charts ─────────────────────────────────────────────────────────────────

// Keep chart instances so we can destroy/recreate on filter changes
const _charts = {};

function destroyChart(id) {
    if (_charts[id]) { _charts[id].destroy(); delete _charts[id]; }
}

// ── Shared stat helpers ─────────────────────────────────────────────────────

function computeGameStats(rounds) {
    let gameWins = 0, gameLosses = 0, twoZeroWins = 0, clutchWins = 0, chokes = 0, allTwoOne = 0;
    for (const r of (rounds || [])) {
        const gw = r.win_count  != null ? r.win_count  : (r.is_win ? 1 : 0);
        const gl = r.lose_count != null ? r.lose_count : (r.is_win ? 0 : 1);
        gameWins   += gw;
        gameLosses += gl;
        if (r.is_win  && gl === 0) twoZeroWins++;
        if (r.is_win  && gl >= 1) { clutchWins++; allTwoOne++; }
        if (!r.is_win && gw >= 1) { chokes++;     allTwoOne++; }
    }
    return { gameWins, gameLosses, twoZeroWins, clutchWins, chokes, allTwoOne };
}

function computeRollingForm(eventData) {
    const evs = [...(eventData || [])]
        .filter(ev => ev?.rounds && ev._start_datetime)
        .sort((a, b) => new Date(a._start_datetime) - new Date(b._start_datetime));
    function pct(slice) {
        let w = 0, l = 0;
        for (const ev of slice) for (const r of ev.rounds) { if (r.is_win) w++; else l++; }
        const t = w + l;
        return t > 0 ? w / t * 100 : null;
    }
    return { last5: pct(evs.slice(-5)), last10: pct(evs.slice(-10)) };
}

function displayCharts(totalW, totalL, periodMap, eventData) {
    const card = document.getElementById('chartsCard');
    if (totalW + totalL === 0) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const accent  = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()   || '#048A81';
    const win     = getComputedStyle(document.documentElement).getPropertyValue('--win').trim()       || '#28a745';
    const loss    = getComputedStyle(document.documentElement).getPropertyValue('--loss').trim()      || '#dc3545';
    const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim()   || '#2E4057';
    const muted   = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim()     || '#6c757d';

    // ── 1. Win / Loss doughnut ──────────────────────────────────────────────
    destroyChart('donut');
    _charts['donut'] = new Chart(document.getElementById('chartDonut'), {
        type: 'doughnut',
        data: {
            labels: ['Wins', 'Losses'],
            datasets: [{ data: [totalW, totalL], backgroundColor: [win, loss], borderWidth: 0 }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '68%',
            plugins: {
                legend: { position: 'bottom', labels: { font: { size: 11 }, color: muted } },
                tooltip: {
                    callbacks: {
                        label: ctx => {
                            const t = totalW + totalL;
                            const pct = (ctx.parsed / t * 100).toFixed(1);
                            return ` ${ctx.parsed} (${pct}%)`;
                        }
                    }
                }
            }
        }
    });

    // ── 2. Results by Set Period bar chart ─────────────────────────────────
    destroyChart('periodBar');
    const periodLabels = [], periodWins = [], periodLosses = [];
    for (const p of SET_PERIODS) {
        const s = periodMap[p.name];
        if (!s || (s.w === 0 && s.l === 0)) continue;
        periodLabels.push(p.name.split(' · ')[0]); // short label
        periodWins.push(s.w);
        periodLosses.push(s.l);
    }
    _charts['periodBar'] = new Chart(document.getElementById('chartPeriodBar'), {
        type: 'bar',
        data: {
            labels: periodLabels,
            datasets: [
                { label: 'Wins',   data: periodWins,   backgroundColor: win  + 'cc', borderRadius: 4 },
                { label: 'Losses', data: periodLosses, backgroundColor: loss + 'cc', borderRadius: 4 }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { stacked: false, ticks: { font: { size: 10 }, color: muted }, grid: { display: false } },
                y: { beginAtZero: true, ticks: { precision: 0, color: muted }, grid: { color: '#eee' } }
            },
            plugins: {
                legend: { position: 'bottom', labels: { font: { size: 11 }, color: muted } },
                tooltip: {
                    callbacks: {
                        footer: items => {
                            const idx  = items[0].dataIndex;
                            const w    = periodWins[idx];
                            const l    = periodLosses[idx];
                            const t    = w + l;
                            const pct  = t > 0 ? (w / t * 100).toFixed(1) : '0.0';
                            return `Win rate: ${pct}%`;
                        }
                    }
                }
            }
        }
    });

    // ── 3. Win rate over time (per tournament, chronological) ──────────────
    destroyChart('timeline');
    const evListChron = [...(eventData || [])].filter(ev => ev?.rounds && ev._start_datetime);
    evListChron.sort((a, b) => new Date(a._start_datetime) - new Date(b._start_datetime));

    const timeLabels = [], timeWinRates = [], timeTotals = [], timeRolling = [];
    let cumW = 0, cumL = 0;
    const ROLLING_N = 5;
    for (let i = 0; i < evListChron.length; i++) {
        const ev = evListChron[i];
        for (const r of ev.rounds) { if (r.is_win) cumW++; else cumL++; }
        const t   = cumW + cumL;
        timeWinRates.push(t > 0 ? parseFloat((cumW / t * 100).toFixed(1)) : 0);
        timeTotals.push(t);
        timeLabels.push(fmtDate(ev._start_datetime));
        // Rolling window
        let rW = 0, rL = 0;
        for (let j = Math.max(0, i - ROLLING_N + 1); j <= i; j++) {
            for (const r of evListChron[j].rounds) { if (r.is_win) rW++; else rL++; }
        }
        const rt = rW + rL;
        timeRolling.push(rt > 0 ? parseFloat((rW / rt * 100).toFixed(1)) : null);
    }

    _charts['timeline'] = new Chart(document.getElementById('chartTimeline'), {
        type: 'line',
        data: {
            labels: timeLabels,
            datasets: [
            {
                label: 'Cumulative Win %',
                data: timeWinRates,
                borderColor: accent,
                backgroundColor: accent + '22',
                fill: true,
                tension: 0.3,
                pointRadius: evListChron.length > 40 ? 0 : 3,
                pointHoverRadius: 5,
                borderWidth: 2
            },
            {
                label: `Rolling ${ROLLING_N} Win %`,
                data: timeRolling,
                borderColor: primary,
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.3,
                pointRadius: 0,
                pointHoverRadius: 4,
                borderWidth: 1.5,
                borderDash: [5, 3]
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    ticks: {
                        font: { size: 9 }, color: muted,
                        maxTicksLimit: 12,
                        maxRotation: 45
                    },
                    grid: { display: false }
                },
                y: {
                    min: 0, max: 100,
                    ticks: {
                        callback: v => v + '%',
                        font: { size: 10 }, color: muted
                    },
                    grid: { color: '#eee' }
                }
            },
            plugins: {
                legend: { position: 'bottom', labels: { font: { size: 11 }, color: muted } },
                tooltip: {
                    callbacks: {
                        title: items => `Tournament: ${items[0].label}`,
                        label: ctx => {
                            if (ctx.datasetIndex === 0)
                                return ` Cumulative: ${ctx.parsed.y}%  (${timeTotals[ctx.dataIndex]} matches)`;
                            return ` Rolling ${ROLLING_N}: ${ctx.parsed.y ?? '—'}%`;
                        }
                    }
                }
            }
        }
    });

    // ── 5. Win Rate by Store ────────────────────────────────────────────────
    {
        const storeMap = {};
        for (const ev of (eventData || [])) {
            if (!ev?.rounds) continue;
            const name = ev._store_name ?? ev.event?.organizer_name ?? ev.event?.organizer
                ?? ev.event?.store_name ?? ev.event?.shop_name ?? null;
            if (!name) continue;
            if (!storeMap[name]) storeMap[name] = { w: 0, l: 0 };
            for (const r of ev.rounds) {
                if (r.is_win) storeMap[name].w++; else storeMap[name].l++;
            }
        }
        const storePanel = document.getElementById('storeChartPanel');
        const storeEntries = Object.entries(storeMap)
            .filter(([, s]) => s.w + s.l >= 2)
            .sort((a, b) => (b[1].w + b[1].l) - (a[1].w + a[1].l));

        if (storeEntries.length === 0) {
            storePanel.style.display = 'none';
        } else {
            storePanel.style.display = '';
            destroyChart('store');
            _charts['store'] = new Chart(document.getElementById('chartStore'), {
                type: 'bar',
                data: {
                    labels: storeEntries.map(([name]) => name),
                    datasets: [
                        { label: 'Wins',   data: storeEntries.map(([,s]) => s.w), backgroundColor: win  + 'cc', borderRadius: 4 },
                        { label: 'Losses', data: storeEntries.map(([,s]) => s.l), backgroundColor: loss + 'cc', borderRadius: 4 }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { stacked: true, ticks: { font: { size: 10 }, color: muted }, grid: { color: '#eee' } },
                        y: { stacked: true, ticks: { font: { size: 10 }, color: muted }, grid: { display: false } }
                    },
                    plugins: {
                        legend: { position: 'bottom', labels: { font: { size: 11 }, color: muted } },
                        tooltip: { callbacks: {
                            afterBody: items => {
                                const [, s] = storeEntries[items[0].dataIndex];
                                const t = s.w + s.l;
                                return [`Win rate: ${(s.w / t * 100).toFixed(1)}%  (${t} matches)`];
                            }
                        }}
                    }
                }
            });
        }
    }

    // ── 6. Streak History (bar) ─────────────────────────────────────────────
    {
        const evsSorted = [...(eventData || [])]
            .filter(ev => ev?.rounds && ev._start_datetime)
            .sort((a, b) => new Date(a._start_datetime) - new Date(b._start_datetime));

        const streakLabels = [];
        const streakData   = [];
        let cur = 0, curType = null;
        for (const ev of evsSorted) {
            for (const r of ev.rounds) {
                if (r.is_win) {
                    cur = curType === 'W' ? cur + 1 : 1;
                    curType = 'W';
                } else {
                    cur = curType === 'L' ? cur + 1 : 1;
                    curType = 'L';
                }
            }
            streakLabels.push(fmtDate(ev._start_datetime));
            streakData.push(curType === 'W' ? cur : -cur);
        }

        destroyChart('streak');
        _charts['streak'] = new Chart(document.getElementById('chartStreak'), {
            type: 'bar',
            data: {
                labels: streakLabels,
                datasets: [{
                    label: 'Streak',
                    data: streakData,
                    backgroundColor: streakData.map(v => v > 0 ? win + 'cc' : loss + 'cc'),
                    borderRadius: 3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { ticks: { font: { size: 9 }, color: muted, maxTicksLimit: 14, maxRotation: 45 }, grid: { display: false } },
                    y: { ticks: { font: { size: 10 }, color: muted,
                            callback: v => v > 0 ? `+${v}W` : `${Math.abs(v)}L`
                         }, grid: { color: '#eee' } }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: { callbacks: {
                        title: items => `Tournament: ${items[0].label}`,
                        label: ctx => {
                            const v = ctx.parsed.y;
                            return v > 0 ? ` Win streak: ${v}` : ` Loss streak: ${Math.abs(v)}`;
                        }
                    }}
                }
            }
        });
    }
}

// ── Streaks ────────────────────────────────────────────────────────────────

function computeStreaks(eventData) {
    const evs = [...(eventData || [])].filter(ev => ev?.rounds && ev._start_datetime);
    evs.sort((a, b) => new Date(a._start_datetime) - new Date(b._start_datetime));
    const rounds = [];
    for (const ev of evs) for (const r of ev.rounds) rounds.push(r.is_win);
    if (!rounds.length) return { current: 0, type: null, bestWin: 0, worstLoss: 0 };

    let bestWin = 0, worstLoss = 0, curW = 0, curL = 0;
    for (const isWin of rounds) {
        if (isWin) { curW++; curL = 0; if (curW > bestWin) bestWin = curW; }
        else       { curL++; curW = 0; if (curL > worstLoss) worstLoss = curL; }
    }
    const type = rounds[rounds.length - 1] ? 'W' : 'L';
    let current = 0;
    for (let i = rounds.length - 1; i >= 0; i--) {
        if (rounds[i] === (type === 'W')) current++; else break;
    }
    return { current, type, bestWin, worstLoss };
}

function displayStreaks(streaks) {
    const el = document.getElementById('streakStats');
    if (!streaks || streaks.current === 0) { el.innerHTML = ''; return; }
    const color = streaks.type === 'W' ? 'var(--win)' : 'var(--loss)';
    el.innerHTML = `<div class="streak-grid">
        <div class="stat-box"><div class="val" style="color:${color}">${streaks.current}${streaks.type}</div><div class="lbl">Current Streak</div></div>
        <div class="stat-box"><div class="val w-val">${streaks.bestWin}</div><div class="lbl">Best Win Streak</div></div>
        <div class="stat-box"><div class="val l-val">${streaks.worstLoss}</div><div class="lbl">Worst Loss Streak</div></div>
    </div>`;
}

// ── Bogeyman / Victim ──────────────────────────────────────────────────────

function displayRivalry(playerMap) {
    const el = document.getElementById('bogeymanStats');
    // Require at least 5 matches against an opponent to qualify
    const MIN_MATCHES = 5;
    let bogeyman = null, victim = null;
    let bogeyPct = 101, victimPct = -1;

    for (const [pid, [w, l]] of Object.entries(playerMap)) {
        const t = w + l;
        if (t < MIN_MATCHES) continue;
        const winPct = w / t * 100;
        // Bogeyman: opponent with lowest win % for us (= they beat us most)
        if (winPct < bogeyPct) { bogeyPct = winPct; bogeyman = { pid, w, l, t, pct: winPct }; }
        // Victim: opponent with highest win % for us
        if (winPct > victimPct) { victimPct = winPct; victim = { pid, w, l, t, pct: winPct }; }
    }

    if (!bogeyman && !victim) { el.innerHTML = ''; return; }

    function rivalryCard(type, data) {
        if (!data) return '';
        const name    = _usernameMap[data.pid] || data.pid;
        const isBogeyman = type === 'bogeyman';
        const emoji   = isBogeyman ? '&#128123;' : '&#128081;';
        const label   = isBogeyman ? 'The Bogeyman' : 'Your Victim';
        const bigNum  = isBogeyman ? `${data.l}L` : `${data.w}W`;
        const record  = isBogeyman
            ? `${data.w}W &ndash; <strong>${data.l}L</strong> &nbsp;(${data.pct.toFixed(1)}% win rate for you)`
            : `<strong>${data.w}W</strong> &ndash; ${data.l}L &nbsp;(${data.pct.toFixed(1)}% win rate for you)`;
        return `<div class="rivalry-card ${type}" onclick="openOpponentModal('${data.pid}')">
            <div class="rivalry-label">${emoji} ${label}</div>
            <div class="rivalry-name">${name}</div>
            <div class="rivalry-record"><strong>${bigNum}</strong><br><span style="font-size:0.8rem;">${record}</span></div>
        </div>`;
    }

    el.innerHTML = `<div class="rivalry-grid">
        ${rivalryCard('bogeyman', bogeyman)}
        ${rivalryCard('victim',   victim)}
    </div>`;
}

// ── Placement History ──────────────────────────────────────────────────────

function displayPlacements(eventData) {
    const section = document.getElementById('placementsInline');

    // Collect events that have a rank, excluding regionals
    const regionalDates = new Set(REGIONALS.map(r => r.date));
    const ranked = (eventData || [])
        .filter(ev => ev?._rank != null && ev._start_datetime
            && !regionalDates.has(ev._start_datetime.slice(0, 10)))
        .sort((a, b) => new Date(b._start_datetime) - new Date(a._start_datetime));

    if (ranked.length === 0) { section.style.display = 'none'; return; }
    section.style.display = '';

    const total = ranked.length;
    const best  = Math.min(...ranked.map(e => e._rank));
    const avg   = (ranked.reduce((s, e) => s + e._rank, 0) / total).toFixed(1);

    // ── Summary stats ──────────────────────────────────────────────────────
    document.getElementById('placementsStats').innerHTML = `
        <div class="stat-box">
            <div class="val" style="color:var(--gold);font-family:'Cinzel',serif;">#${best}</div>
            <div class="lbl">Best Placement</div>
        </div>
        <div class="stat-box">
            <div class="val t-val">#${avg}</div>
            <div class="lbl">Avg Placement</div>
        </div>
        <div class="stat-box">
            <div class="val pct-val">${total}</div>
            <div class="lbl">Events w/ Rank</div>
        </div>`;

    // ── Tier breakdown ─────────────────────────────────────────────────────
    const tiers = [
        { label: '1st Place', max: 1,        color: '#c9a84c' },
        { label: 'Top 4',     max: 4,        color: '#048A81' },
        { label: 'Top 8',     max: 8,        color: '#2E4057' },
        { label: 'Top 16',    max: 16,       color: '#6c757d' },
        { label: 'Top 32',    max: 32,       color: '#adb5bd' },
        { label: '33+',       max: Infinity, color: '#dee2e6' },
    ];

    const counts = tiers.map(() => 0);
    for (const ev of ranked) {
        const idx = tiers.findIndex(t => ev._rank <= t.max);
        if (idx !== -1) counts[idx]++;
    }

    const maxCount = Math.max(...counts, 1);
    const tiersEl  = document.getElementById('placementsTiers');
    tiersEl.innerHTML = '';
    tiers.forEach((t, i) => {
        if (counts[i] === 0) return;
        const pct  = (counts[i] / total * 100).toFixed(0);
        const barW = (counts[i] / maxCount * 100).toFixed(1);
        const row  = document.createElement('div');
        row.className = 'tier-row';
        row.innerHTML = `
            <span class="tier-label">${t.label}</span>
            <div class="tier-bar-wrap">
                <div class="tier-bar" style="width:${barW}%;background:${t.color};"></div>
            </div>
            <span class="tier-count">${counts[i]}</span>
            <span class="tier-pct">${pct}%</span>`;
        tiersEl.appendChild(row);
    });
}

// ── Monthly breakdown ──────────────────────────────────────────────────────

function displayMonthly(eventData) {
    const card = document.getElementById('monthlyCard');
    const monthly = {};
    for (const ev of (eventData || [])) {
        if (!ev?.rounds || !ev._start_datetime) continue;
        const d = new Date(ev._start_datetime);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        if (!monthly[key]) monthly[key] = { w: 0, l: 0 };
        for (const r of ev.rounds) { if (r.is_win) monthly[key].w++; else monthly[key].l++; }
    }
    const keys = Object.keys(monthly).sort();
    if (!keys.length) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const tbody = document.getElementById('monthlyBody');
    tbody.innerHTML = '';
    for (const key of keys) {
        const s = monthly[key];
        const t = s.w + s.l;
        const pct = (s.w / t * 100).toFixed(1);
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${key}</td>
            <td class="td-num">${s.w}</td><td class="td-num">${s.l}</td>
            <td class="td-num">${t}</td><td class="td-pct">${pct}%</td>`;
        tbody.appendChild(tr);
    }

    destroyChart('monthly');
    const win   = getComputedStyle(document.documentElement).getPropertyValue('--win').trim()   || '#28a745';
    const loss  = getComputedStyle(document.documentElement).getPropertyValue('--loss').trim()  || '#dc3545';
    const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#6c757d';
    _charts['monthly'] = new Chart(document.getElementById('chartMonthly'), {
        type: 'bar',
        data: {
            labels: keys,
            datasets: [
                { label: 'Wins',   data: keys.map(k => monthly[k].w), backgroundColor: win  + 'cc', borderRadius: 3 },
                { label: 'Losses', data: keys.map(k => monthly[k].l), backgroundColor: loss + 'cc', borderRadius: 3 }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { stacked: true, ticks: { font: { size: 9 }, color: muted, maxRotation: 45 }, grid: { display: false } },
                y: { stacked: true, beginAtZero: true, ticks: { precision: 0, color: muted }, grid: { color: '#eee' } }
            },
            plugins: {
                legend: { position: 'bottom', labels: { font: { size: 11 }, color: muted } },
                tooltip: {
                    callbacks: {
                        footer: items => {
                            const s = monthly[items[0].label];
                            const t = s.w + s.l;
                            return `Win rate: ${(s.w / t * 100).toFixed(1)}%`;
                        }
                    }
                }
            }
        }
    });
}

// ── Performance by event size ──────────────────────────────────────────────

function displayEventSize(eventData) {
    const card = document.getElementById('eventSizeCard');
    const brackets = [
        { label: 'Small (≤ 16)',   test: n => n !== null && n <= 16 },
        { label: 'Medium (17–32)', test: n => n !== null && n >= 17 && n <= 32 },
        { label: 'Large (33+)',    test: n => n !== null && n >= 33 },
        { label: 'Unknown',        test: n => n === null },
    ];
    const stats = brackets.map(() => ({ w: 0, l: 0 }));
    let hasData = false;
    for (const ev of (eventData || [])) {
        if (!ev?.rounds) continue;
        const n = ev._applicant_count ?? null;
        const bi = brackets.findIndex(b => b.test(n));
        if (bi === -1) continue;
        for (const r of ev.rounds) {
            if (r.is_win) stats[bi].w++; else stats[bi].l++;
            hasData = true;
        }
    }
    if (!hasData) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const tbody = document.getElementById('eventSizeBody');
    tbody.innerHTML = '';
    for (let i = 0; i < brackets.length; i++) {
        const s = stats[i];
        if (s.w === 0 && s.l === 0) continue;
        const t = s.w + s.l;
        const pct = (s.w / t * 100).toFixed(1);
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${brackets[i].label}</td>
            <td class="td-num">${s.w}</td><td class="td-num">${s.l}</td>
            <td class="td-num">${t}</td><td class="td-pct">${pct}%</td>`;
        tbody.appendChild(tr);
    }
}

// ── Round by round ─────────────────────────────────────────────────────────

function displayRoundByRound(eventData) {
    const card = document.getElementById('roundCard');
    const roundMap = {};
    for (const ev of (eventData || [])) {
        if (!ev?.rounds) continue;
        ev.rounds.forEach((r, idx) => {
            if (!roundMap[idx]) roundMap[idx] = { w: 0, l: 0 };
            if (r.is_win) roundMap[idx].w++; else roundMap[idx].l++;
        });
    }
    const indices = Object.keys(roundMap).map(Number).sort((a, b) => a - b);
    if (!indices.length) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const tbody = document.getElementById('roundBody');
    tbody.innerHTML = '';
    for (const idx of indices) {
        const s = roundMap[idx];
        const t = s.w + s.l;
        const pct = (s.w / t * 100).toFixed(1);
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>Round ${idx + 1}</td>
            <td class="td-num">${s.w}</td><td class="td-num">${s.l}</td>
            <td class="td-num">${t}</td><td class="td-pct">${pct}%</td>`;
        tbody.appendChild(tr);
    }

    // Chart
    const accent  = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()  || '#048A81';
    const win     = getComputedStyle(document.documentElement).getPropertyValue('--win').trim()      || '#28a745';
    const muted   = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim()    || '#6c757d';
    destroyChart('roundBar');
    _charts['roundBar'] = new Chart(document.getElementById('chartRoundBar'), {
        type: 'bar',
        data: {
            labels: indices.map(i => `Round ${i + 1}`),
            datasets: [{
                label: 'Win %',
                data: indices.map(i => {
                    const s = roundMap[i]; return s ? +(s.w / (s.w + s.l) * 100).toFixed(1) : 0;
                }),
                backgroundColor: indices.map(i => {
                    const s = roundMap[i];
                    const pct = s ? s.w / (s.w + s.l) * 100 : 0;
                    return pct >= 50 ? win + 'cc' : '#dc3545cc';
                }),
                borderRadius: 4
            }]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { min: 0, max: 100, ticks: { callback: v => v + '%', font: { size: 10 }, color: muted }, grid: { color: '#eee' } },
                y: { ticks: { font: { size: 11 }, color: muted }, grid: { display: false } }
            },
            plugins: {
                legend: { display: false },
                tooltip: { callbacks: {
                    label: ctx => {
                        const i = indices[ctx.dataIndex];
                        const s = roundMap[i];
                        return ` Win%: ${ctx.parsed.x}%  (${s.w}W / ${s.l}L)`;
                    }
                }}
            }
        }
    });

    // ── Most Faced Opponent per Round ───────────────────────────────────────
    const MAX_ROUND = 5;
    // roundOppMap[idx][pid] = { w, l, count }
    const roundOppMap = {};
    for (const ev of (eventData || [])) {
        if (!ev?.rounds) continue;
        ev.rounds.forEach((r, idx) => {
            if (idx >= MAX_ROUND) return;
            const pid = r.opponent_users?.[0]?.membership_number;
            if (!pid) return;
            if (!roundOppMap[idx]) roundOppMap[idx] = {};
            if (!roundOppMap[idx][pid]) roundOppMap[idx][pid] = { w: 0, l: 0 };
            if (r.is_win) roundOppMap[idx][pid].w++; else roundOppMap[idx][pid].l++;
        });
    }

    const section = document.getElementById('roundOppSection');
    const grid    = document.getElementById('roundOppGrid');
    grid.innerHTML = '';
    let anyFound = false;

    for (let idx = 0; idx < MAX_ROUND; idx++) {
        const oppMap = roundOppMap[idx];
        if (!oppMap) continue;

        // Pick opponent with most appearances in this round slot
        const top = Object.entries(oppMap)
            .sort((a, b) => (b[1].w + b[1].l) - (a[1].w + a[1].l))[0];
        if (!top) continue;

        anyFound = true;
        const [pid, stats] = top;
        const name  = _usernameMap[pid] || pid;
        const times = stats.w + stats.l;
        const winColor  = getComputedStyle(document.documentElement).getPropertyValue('--win').trim()  || '#28a745';
        const lossColor = getComputedStyle(document.documentElement).getPropertyValue('--loss').trim() || '#dc3545';
        const recColor  = stats.w >= stats.l ? winColor : lossColor;

        const card = document.createElement('div');
        card.className = 'round-opp-card';
        card.title = `Open ${name}'s profile`;
        card.onclick = () => openOpponentModal(pid);
        card.innerHTML = `
            <div class="roc-round">Round ${idx + 1}</div>
            <div class="roc-name">${name}</div>
            <div class="roc-count">${times}× faced</div>
            <div class="roc-record" style="color:${recColor}">${stats.w}W &ndash; ${stats.l}L</div>`;
        grid.appendChild(card);
    }

    section.style.display = anyFound ? '' : 'none';
}

// ── Opponent profile modal ─────────────────────────────────────────────────

function openOpponentModal(pid) {
    const name    = _usernameMap[pid] || pid;
    const history = _opponentMatchHistory[pid] || [];
    const [w, l]  = _playerResults[pid] || [0, 0];
    const t       = w + l;
    const pct     = t > 0 ? (w / t * 100).toFixed(1) : '0.0';

    document.getElementById('modalPlayerName').textContent = `vs ${name}`;
    document.getElementById('modalPlayerRecord').innerHTML =
        `<span style="color:var(--win)">${w}W</span> / <span style="color:var(--loss)">${l}L</span> — ${pct}% win rate · ${history.length} event${history.length !== 1 ? 's' : ''}`;

    const tbody = document.getElementById('modalMatchBody');
    tbody.innerHTML = '';
    const sorted = [...history].sort((a, b) => b.dateStr.localeCompare(a.dateStr));
    for (const m of sorted) {
        const tr = document.createElement('tr');
        const resultColor = m.w > m.l ? 'var(--win)' : m.l > m.w ? 'var(--loss)' : 'var(--muted)';
        const resultStr = `${m.w}W-${m.l}L`;
        const gameStr   = (m.gw != null && m.gl != null) ? `${m.gw}-${m.gl}` : '—';
        tr.innerHTML = `<td>${fmtDate(m.dateStr)}</td><td>${m.evName}</td>
            <td class="td-num" style="color:${resultColor};font-weight:600">${resultStr}</td>
            <td class="td-num">${gameStr}</td>`;
        tbody.appendChild(tr);
    }
    document.getElementById('opponentModal').classList.add('open');
}

function closeOpponentModal(event) {
    if (event.target === document.getElementById('opponentModal'))
        document.getElementById('opponentModal').classList.remove('open');
}

// ── Multi-user comparison ──────────────────────────────────────────────────

function buildCompareCard() {
    const card = document.getElementById('compareCard');
    if (_usersWithToken.length < 2) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const currentIdx = parseInt(document.getElementById('userSelect').value);
    const sel = document.getElementById('compareUserSelect');
    sel.innerHTML = '<option value="">— select a user —</option>';
    _usersWithToken.forEach((u, i) => {
        if (i === currentIdx) return;
        const opt = document.createElement('option');
        opt.value = i; opt.textContent = u.name;
        sel.appendChild(opt);
    });
    document.getElementById('compareContent').innerHTML = '';
}

function onCompareUserChange() {
    const idx = document.getElementById('compareUserSelect').value;
    if (idx === '') { document.getElementById('compareContent').innerHTML = ''; return; }

    const currentIdx = parseInt(document.getElementById('userSelect').value);
    const userA = _usersWithToken[currentIdx];
    const userB = _usersWithToken[parseInt(idx)];

    const cacheB = loadCache(userB.bandaiId);
    const evDataB = Object.values(cacheB);
    if (evDataB.length === 0) {
        document.getElementById('compareContent').innerHTML =
            `<p style="color:var(--muted);font-size:0.88rem;">No cached data for <strong>${userB.name}</strong>. Run Fetch &amp; Analyze for that user first.</p>`;
        return;
    }
    renderCompare(computeUserStats(userA.name, _allEventData), computeUserStats(userB.name, evDataB));
}

function computeUserStats(name, eventData) {
    let w = 0, l = 0, tournaments = 0;
    const periodMap = {};
    for (const p of SET_PERIODS) periodMap[p.name] = { w: 0, l: 0 };
    for (const ev of eventData) {
        if (!ev?.rounds) continue;
        tournaments++;
        const period = ev._start_datetime ? getPeriodForDate(ev._start_datetime) : SET_PERIODS[0].name;
        for (const r of ev.rounds) {
            if (r.is_win) { w++; periodMap[period].w++; } else { l++; periodMap[period].l++; }
        }
    }
    let bestPeriod = null, bestPct = -1;
    for (const [pname, s] of Object.entries(periodMap)) {
        const t = s.w + s.l;
        if (t < 3) continue;
        const pct = s.w / t * 100;
        if (pct > bestPct) { bestPct = pct; bestPeriod = pname.split(' · ')[0]; }
    }
    return { name, w, l, tournaments, bestPeriod, bestPct };
}

function renderCompare(a, b) {
    const tA = a.w + a.l, tB = b.w + b.l;
    const pctA = tA > 0 ? (a.w / tA * 100).toFixed(1) : '0.0';
    const pctB = tB > 0 ? (b.w / tB * 100).toFixed(1) : '0.0';
    const aLeads = parseFloat(pctA) > parseFloat(pctB);
    const bLeads = parseFloat(pctB) > parseFloat(pctA);

    function userBox(u, pct, leads) {
        return `<div class="compare-user-box ${leads ? 'compare-active' : ''}">
            <h3>${u.name}${leads ? ' ◀' : ''}</h3>
            <div class="stat-grid" style="grid-template-columns:repeat(2,1fr);gap:0.6rem;">
                <div class="stat-box"><div class="val w-val" style="font-size:1.5rem">${u.w}</div><div class="lbl">Wins</div></div>
                <div class="stat-box"><div class="val l-val" style="font-size:1.5rem">${u.l}</div><div class="lbl">Losses</div></div>
                <div class="stat-box"><div class="val pct-val" style="font-size:1.5rem">${pct}%</div><div class="lbl">Win Rate</div></div>
                <div class="stat-box"><div class="val t-val" style="font-size:1.5rem">${u.tournaments}</div><div class="lbl">Events</div></div>
            </div>
            <div class="compare-bar-wrap">
                <div class="compare-bar-label">
                    <span>Win Rate</span>
                    <span class="${leads ? 'compare-winner' : ''}">${pct}%</span>
                </div>
                <div class="compare-bar"><div class="compare-bar-fill" style="width:${pct}%"></div></div>
            </div>
            ${u.bestPeriod ? `<p style="font-size:0.78rem;color:var(--muted);margin-top:0.6rem;">Best set: <strong>${u.bestPeriod}</strong> (${u.bestPct.toFixed(1)}%)</p>` : ''}
        </div>`;
    }
    document.getElementById('compareContent').innerHTML =
        `<div class="compare-cols">${userBox(a, pctA, aLeads)}${userBox(b, pctB, bLeads)}</div>`;
}

// ── Feature 1: Round-by-Round Heatmap ──────────────────────────────────────
function displayRoundHeatmap(eventData) {
    const card = document.getElementById('heatmapCard');
    const evs  = (eventData || [])
        .filter(ev => ev?.rounds?.length && ev._start_datetime)
        .sort((a, b) => new Date(a._start_datetime) - new Date(b._start_datetime));
    if (evs.length === 0) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const maxR = Math.max(...evs.map(ev => ev.rounds.length));
    const colW = Array(maxR).fill(0), colL = Array(maxR).fill(0);

    let html = '<table class="heatmap-table"><thead><tr><th>Event</th>';
    for (let r = 0; r < maxR; r++) html += `<th>R${r + 1}</th>`;
    html += '</tr></thead><tbody>';

    for (const ev of evs) {
        const dateStr = ev._start_datetime.slice(0, 10);
        html += `<tr><td style="font-size:0.72rem;color:var(--muted);white-space:nowrap;padding-right:0.5rem;">${dateStr}</td>`;
        for (let r = 0; r < maxR; r++) {
            const round = ev.rounds[r];
            if (!round) {
                html += '<td><span class="heatmap-dot none" title="Not played"></span></td>';
            } else if (round.is_win) {
                html += '<td><span class="heatmap-dot win" title="Win"></span></td>';
                colW[r]++;
            } else {
                html += '<td><span class="heatmap-dot loss" title="Loss"></span></td>';
                colL[r]++;
            }
        }
        html += '</tr>';
    }

    html += '<tr class="heatmap-pct-row"><td style="font-size:0.72rem;font-weight:700;color:var(--muted);">Win %</td>';
    for (let r = 0; r < maxR; r++) {
        const t = colW[r] + colL[r];
        const pct = t > 0 ? (colW[r] / t * 100).toFixed(0) : '—';
        const color = t > 0 ? ((colW[r] / t) >= 0.5 ? 'var(--win)' : 'var(--loss)') : 'var(--muted)';
        html += `<td style="color:${color}">${pct}${t > 0 ? '%' : ''}</td>`;
    }
    html += '</tr></tbody></table>';
    document.getElementById('heatmapGrid').innerHTML = html;
}

// ── Feature 2: Recurring Opponents ─────────────────────────────────────────
function displayRecurringOpponents(eventData) {
    const card = document.getElementById('recurringCard');
    const evOppDates = {}, evOppWL = {};

    for (const ev of (eventData || [])) {
        if (!ev?.rounds) continue;
        const dateStr = ev._start_datetime ? ev._start_datetime.slice(0, 10) : null;
        const seenInEv = new Set();
        for (const r of ev.rounds) {
            const pid = r.opponent_users?.[0]?.membership_number;
            if (!pid) continue;
            if (!seenInEv.has(pid)) {
                seenInEv.add(pid);
                if (!evOppDates[pid]) evOppDates[pid] = [];
                if (dateStr) evOppDates[pid].push(dateStr);
            }
            if (!evOppWL[pid]) evOppWL[pid] = { w: 0, l: 0 };
            if (r.is_win) evOppWL[pid].w++; else evOppWL[pid].l++;
        }
    }

    const recurring = Object.entries(evOppDates)
        .filter(([, dates]) => dates.length >= 2)
        .sort((a, b) => b[1].length - a[1].length);

    if (recurring.length === 0) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const tbody = document.getElementById('recurringBody');
    tbody.innerHTML = '';
    for (const [pid, dates] of recurring) {
        const sorted = [...dates].sort();
        const name   = _usernameMap[pid] || pid;
        const { w, l } = evOppWL[pid] || { w: 0, l: 0 };
        const t   = w + l;
        const pct = t > 0 ? (w / t * 100).toFixed(1) : '0.0';
        const tr  = document.createElement('tr');
        tr.style.cursor = 'pointer';
        tr.title = 'Click to view match history';
        tr.onclick = () => openOpponentModal(pid);
        tr.innerHTML = `<td>${name}</td>
            <td class="td-num">${dates.length}</td>
            <td class="td-num" style="color:var(--win)">${w}</td>
            <td class="td-num" style="color:var(--loss)">${l}</td>
            <td class="td-pct">${pct}%</td>
            <td class="td-num">${sorted[0] ?? '—'}</td>
            <td class="td-num">${sorted[sorted.length - 1] ?? '—'}</td>`;
        tbody.appendChild(tr);
    }
}

// ── Feature 6: Store Performance Breakdown ──────────────────────────────────
function displayStoreBreakdown(eventData) {
    const card = document.getElementById('storeBreakCard');
    const storeMap = {};
    for (const ev of (eventData || [])) {
        if (!ev?.rounds) continue;
        const name = ev._store_name ?? null;
        if (!name) continue;
        if (!storeMap[name]) storeMap[name] = { events: 0, w: 0, l: 0 };
        storeMap[name].events++;
        for (const r of ev.rounds) { if (r.is_win) storeMap[name].w++; else storeMap[name].l++; }
    }
    const entries = Object.entries(storeMap)
        .sort((a, b) => {
            const ta = a[1].w + a[1].l, tb = b[1].w + b[1].l;
            const pa = ta ? a[1].w / ta : 0, pb = tb ? b[1].w / tb : 0;
            return pb - pa;
        });
    if (entries.length === 0) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const tbody = document.getElementById('storeBreakBody');
    tbody.innerHTML = '';
    for (const [name, s] of entries) {
        const t   = s.w + s.l;
        const pct = t > 0 ? (s.w / t * 100).toFixed(1) : '0.0';
        const color = parseFloat(pct) >= 50 ? 'var(--win)' : 'var(--loss)';
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${name}</td>
            <td class="td-num">${s.events}</td>
            <td class="td-num" style="color:var(--win)">${s.w}</td>
            <td class="td-num" style="color:var(--loss)">${s.l}</td>
            <td class="td-pct" style="color:${color}">${pct}%</td>`;
        tbody.appendChild(tr);
    }
}

// ── Feature 7: Seasonality Polar Chart ─────────────────────────────────────
function displaySeasonality(eventData) {
    const card = document.getElementById('seasonalityCard');
    const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const ms = Array.from({ length: 12 }, () => ({ w: 0, l: 0 }));
    for (const ev of (eventData || [])) {
        if (!ev?.rounds || !ev._start_datetime) continue;
        const m = new Date(ev._start_datetime).getMonth();
        for (const r of ev.rounds) { if (r.is_win) ms[m].w++; else ms[m].l++; }
    }
    if (!ms.some(s => s.w + s.l > 0)) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#6c757d';
    const pcts  = ms.map(s => { const t = s.w + s.l; return t > 0 ? parseFloat((s.w / t * 100).toFixed(1)) : null; });

    destroyChart('seasonality');
    _charts['seasonality'] = new Chart(document.getElementById('chartSeasonality'), {
        type: 'polarArea',
        data: {
            labels: MONTHS,
            datasets: [{
                data: pcts.map(p => p ?? 0),
                backgroundColor: pcts.map(p =>
                    p === null ? 'rgba(0,0,0,0.04)' :
                    p >= 60 ? '#28a74555' : p >= 50 ? '#048A8155' : '#dc354555'),
                borderColor: pcts.map(p =>
                    p === null ? 'var(--border)' :
                    p >= 60 ? 'var(--win)' : p >= 50 ? 'var(--accent)' : 'var(--loss)'),
                borderWidth: 1.5
            }]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            scales: { r: {
                min: 0, max: 100,
                ticks: { stepSize: 25, callback: v => v + '%', font: { size: 9 }, color: muted },
                grid: { color: 'rgba(0,0,0,0.07)' }
            }},
            plugins: {
                legend: { display: false },
                tooltip: { callbacks: { label: ctx => {
                    const s = ms[ctx.dataIndex];
                    const t = s.w + s.l;
                    return t > 0 ? ` ${ctx.parsed.r}% (${s.w}W / ${s.l}L, ${t} matches)` : ' No data';
                }}}
            }
        }
    });
}

// ── Feature 8: Personal Bests ───────────────────────────────────────────────
function displayPersonalBests(eventData, streaks) {
    const card = document.getElementById('personalBestsCard');
    if (!eventData || eventData.length === 0) { card.style.display = 'none'; return; }

    let bestEvPct = null, bestEvDate = '—';
    let bestRank  = null;
    let mostRounds = 0, mostRoundsDate = '—';
    const monthCount = {};

    for (const ev of eventData) {
        if (!ev?.rounds) continue;
        const dateStr = ev._start_datetime ? ev._start_datetime.slice(0, 10) : null;

        let evW = 0, evL = 0;
        for (const r of ev.rounds) { if (r.is_win) evW++; else evL++; }
        const evT = evW + evL;
        if (evT > 0) {
            const evPct = evW / evT * 100;
            if (bestEvPct === null || evPct > bestEvPct) { bestEvPct = evPct; bestEvDate = dateStr ?? '—'; }
        }

        const rank = ev._rank ?? null;
        if (rank !== null && (bestRank === null || rank < bestRank)) bestRank = rank;

        if (ev.rounds.length > mostRounds) { mostRounds = ev.rounds.length; mostRoundsDate = dateStr ?? '—'; }

        if (dateStr) {
            const mk = dateStr.slice(0, 7);
            monthCount[mk] = (monthCount[mk] || 0) + 1;
        }
    }

    const bestMonth = Object.entries(monthCount).sort((a, b) => b[1] - a[1])[0];

    card.style.display = 'block';
    document.getElementById('personalBestsGrid').innerHTML = `
        <div class="stat-box"><div class="val w-val">${streaks?.bestWin ?? 0}</div><div class="lbl">Best Win Streak</div></div>
        <div class="stat-box">
            <div class="val pct-val">${bestEvPct !== null ? bestEvPct.toFixed(1) + '%' : '—'}</div>
            <div class="lbl">Best Event Win%<br><span style="font-size:0.65rem;color:var(--muted)">${bestEvDate}</span></div>
        </div>
        <div class="stat-box">
            <div class="val" style="color:var(--gold)">${bestRank !== null ? '#' + bestRank : '—'}</div>
            <div class="lbl">Highest Rank</div>
        </div>
        <div class="stat-box">
            <div class="val t-val">${mostRounds}</div>
            <div class="lbl">Most Rounds in Event<br><span style="font-size:0.65rem;color:var(--muted)">${mostRoundsDate}</span></div>
        </div>
        <div class="stat-box">
            <div class="val t-val">${bestMonth ? bestMonth[1] : '—'}</div>
            <div class="lbl">Most Events in Month<br><span style="font-size:0.65rem;color:var(--muted)">${bestMonth ? bestMonth[0] : ''}</span></div>
        </div>`;
}

// ── Regionals ──────────────────────────────────────────────────────────────
function displayRegionals(eventData) {
    // Build a map of date → event data for quick lookup
    const byDate = {};
    for (const ev of (eventData || [])) {
        if (!ev?._start_datetime) continue;
        const d = ev._start_datetime.slice(0, 10);
        if (!byDate[d]) byDate[d] = ev;
    }

    const card = document.getElementById('regionalsCard');
    const body = document.getElementById('regionalsBody');
    body.innerHTML = '';

    // Show card only if at least one regional is defined
    if (REGIONALS.length === 0) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    for (const reg of REGIONALS) {
        const ev = byDate[reg.date];
        let resultStr = '—';

        if (ev?.rounds) {
            let evW = 0, evL = 0;
            for (const r of ev.rounds) { if (r.is_win) evW++; else evL++; }
            resultStr = `${evW}-${evL}`;
        }

        const tr = document.createElement('tr');
        if (!ev?.rounds) tr.style.opacity = '0.5'; // not yet attended
        tr.innerHTML = `<td>${fmtDate(reg.date)}</td>
            <td>${reg.name}</td>
            <td class="td-num">${resultStr}</td>`;
        body.appendChild(tr);
    }

    // Scatter: tournament size vs final rank (or win% as fallback)
    {
        const scatterPanel = document.getElementById('regionalScatterPanel');
        const scatterPoints = [];
        const scatterLabels = [];
        const scatterMeta   = []; // { rank, winPct, applicants }
        let   useRank = false;

        for (const reg of REGIONALS) {
            const ev = byDate[reg.date];
            if (!ev?.rounds) continue;
            const applicants = ev._applicant_count ?? null;
            if (applicants === null) continue;
            let evW = 0, evL = 0;
            for (const r of ev.rounds) { if (r.is_win) evW++; else evL++; }
            const t = evW + evL;
            if (t === 0) continue;
            const rank   = ev._rank ?? null;
            const winPct = +(evW / t * 100).toFixed(1);
            if (rank !== null) useRank = true;
            scatterMeta.push({ rank, winPct, applicants });
            scatterLabels.push(reg.name);
        }

        // Build points: prefer rank on Y when available for all events, else win%
        for (const m of scatterMeta) {
            const y = useRank ? (m.rank ?? m.winPct) : m.winPct;
            scatterPoints.push({ x: m.applicants, y });
        }

        // Update subtitle accordingly
        const scatterTitle = document.querySelector('#regionalScatterPanel h3');
        const scatterSub   = document.querySelector('#regionalScatterPanel p');
        if (scatterTitle) scatterTitle.textContent = useRank
            ? 'Tournament Size vs. Final Rank'
            : 'Tournament Size vs. Result';
        if (scatterSub) scatterSub.textContent = useRank
            ? 'Each dot is a regional event. X = applicants, Y = final rank (lower is better).'
            : 'Each dot is a regional event. X = applicants, Y = win % achieved.';

        if (scatterPoints.length < 2) {
            scatterPanel.style.display = 'none';
        } else {
            scatterPanel.style.display = '';
            const scMuted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#6c757d';
            destroyChart('regionalScatter');
            _charts['regionalScatter'] = new Chart(document.getElementById('chartRegionalScatter'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Regional',
                        data: scatterPoints,
                        backgroundColor: scatterPoints.map((p, i) => {
                            if (useRank) {
                                // lower rank = better (top half of field)
                                const half = (scatterMeta[i].applicants || 2) / 2;
                                return p.y <= half ? '#28a745cc' : '#dc3545cc';
                            }
                            return p.y >= 50 ? '#28a745cc' : '#dc3545cc';
                        }),
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Applicants', color: scMuted, font: { size: 11 } },
                             ticks: { font: { size: 10 }, color: scMuted }, grid: { color: '#eee' } },
                        y: useRank
                            ? { reverse: true,
                                title: { display: true, text: 'Final Rank (lower = better)', color: scMuted, font: { size: 11 } },
                                ticks: { callback: v => `#${v}`, font: { size: 10 }, color: scMuted },
                                grid: { color: '#eee' } }
                            : { min: 0, max: 100,
                                title: { display: true, text: 'Win %', color: scMuted, font: { size: 11 } },
                                ticks: { callback: v => v + '%', font: { size: 10 }, color: scMuted },
                                grid: { color: '#eee' } }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: {
                            label: ctx => {
                                const m   = scatterMeta[ctx.dataIndex];
                                const lbl = scatterLabels[ctx.dataIndex];
                                const lines = [`${lbl}`, `Applicants: ${m.applicants}`];
                                if (m.rank   != null) lines.push(`Final rank: #${m.rank}`);
                                lines.push(`Win rate: ${m.winPct}%`);
                                return lines;
                            }
                        }}
                    }
                }
            });
        }
    }
}

// ── Sortable tables ────────────────────────────────────────────────────────

const sortState = {};
function sortTable(tableId, col) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector('tbody');
    const rows  = Array.from(tbody.querySelectorAll('tr'));
    const key   = tableId + '_' + col;
    const asc   = sortState[key] !== true;
    sortState[key] = asc;

    table.querySelectorAll('thead th').forEach((th, i) => {
        th.classList.remove('sorted-asc', 'sorted-desc');
        if (i === col) th.classList.add(asc ? 'sorted-asc' : 'sorted-desc');
    });

    rows.sort((a, b) => {
        // Strip formatting chars so numeric values always parse correctly:
        // %, #, leading/trailing spaces; also handle "X / Y" and "X-Y" by taking first number
        const clean = v => v.replace(/[%#]/g, '').trim();
        let av = clean(a.cells[col].textContent);
        let bv = clean(b.cells[col].textContent);
        const an = parseFloat(av), bn = parseFloat(bv);
        if (!isNaN(an) && !isNaN(bn)) return asc ? an - bn : bn - an;
        return asc ? av.localeCompare(bv) : bv.localeCompare(av);
    });
    rows.forEach(r => tbody.appendChild(r));
}

// ── API Field Inspector ────────────────────────────────────────────────────

function toggleInspector() {
    const card = document.getElementById('inspectorCard');
    if (card.style.display === 'none') {
        buildInspector();
        card.style.display = '';
        // ensure body is not collapsed
        document.getElementById('inspector-body').classList.remove('collapsed');
    } else {
        card.style.display = 'none';
    }
}

function syntaxHighlight(json) {
    // Escape HTML then colorise keys, strings, numbers, booleans, nulls
    return json
        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, match => {
            if (/^"/.test(match)) {
                if (/:$/.test(match)) return `<span class="inspector-key">${match}</span>`;
                return `<span class="inspector-str">${match}</span>`;
            }
            if (/true|false/.test(match)) return `<span class="inspector-bool">${match}</span>`;
            if (/null/.test(match))       return `<span class="inspector-null">${match}</span>`;
            return `<span class="inspector-num">${match}</span>`;
        });
}

function makeBlock(id, data) {
    const json = JSON.stringify(data, null, 2);
    const highlighted = syntaxHighlight(json);
    return `<div class="inspector-block" id="${id}">` +
        `<button class="inspector-copy" onclick="copyInspector('${id}','${id}-btn')" id="${id}-btn">Copy</button>` +
        highlighted +
        `</div>`;
}

function copyInspector(blockId, btnId) {
    const text = document.getElementById(blockId).innerText.replace(/^Copy\n?/, '');
    navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById(btnId);
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 1800);
    });
}

function buildInspector() {
    const container = document.getElementById('inspectorSections');
    container.innerHTML = '';

    if (!_allEventData || _allEventData.length === 0) {
        container.innerHTML = '<p style="color:var(--loss)">No event data loaded yet. Fetch data first.</p>';
        return;
    }

    // Pick the first event that has rounds
    const ev = _allEventData.find(e => e?.rounds?.length) || _allEventData[0];

    // 1. Top-level event history keys (strip rounds for brevity, show separately)
    const evTop = Object.fromEntries(
        Object.entries(ev).filter(([k]) => k !== 'rounds')
    );

    // 2. Nested event object (if present)
    const evNested = ev.event ?? null;

    // 3. First round object
    const round0 = ev.rounds?.[0] ?? null;

    // 4. opponent_users entry (if present)
    const oppUser = round0?.opponent_users?.[0] ?? null;

    const sections = [
        { label: 'Event History — top-level fields (rounds excluded)', id: 'isp-evtop', data: evTop },
        { label: 'Event History — nested `event` object', id: 'isp-evnested', data: evNested },
        { label: 'Round object — rounds[0]', id: 'isp-round', data: round0 },
        { label: 'Opponent user — rounds[0].opponent_users[0]', id: 'isp-oppuser', data: oppUser },
    ];

    for (const s of sections) {
        const div = document.createElement('div');
        div.className = 'inspector-section';
        div.innerHTML = `<h3>${s.label}</h3>` + (s.data !== null ? makeBlock(s.id, s.data) : `<p style="color:var(--muted);font-size:0.82rem;">Not present in this event.</p>`);
        container.appendChild(div);
    }
}

// ── Dark / Light mode ──────────────────────────────────────────────────────

function applyTheme(dark) {
    document.documentElement.setAttribute('data-theme', dark ? 'dark' : 'light');
    const btn = document.getElementById('themeToggleBtn');
    if (btn) btn.innerHTML = dark ? '&#9728;&#65039; Light' : '&#127775; Dark';
    // Update wave SVG fill to match background
    const wavePath = document.getElementById('wavePath');
    if (wavePath) {
        const bg = getComputedStyle(document.documentElement).getPropertyValue('--wave-fill').trim();
        wavePath.setAttribute('fill', bg);
    }
    // Redraw charts so colors update
    if (typeof _allEventData !== 'undefined' && _allEventData.length) {
        const sel = document.getElementById('userSelect');
        if (sel && sel.value !== '') applyFilter();
    }
    // Redraw rankings progression chart if visible
    if (document.getElementById('rankingsTab')?.style.display !== 'none') buildGlobalRankings();
}

function toggleTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const next   = !isDark;
    localStorage.setItem('op-theme', next ? 'dark' : 'light');
    applyTheme(next);
}

// Apply saved or system preference on load
(function () {
    const saved  = localStorage.getItem('op-theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    applyTheme(saved ? saved === 'dark' : prefersDark);
})();

// ── Global Rankings ────────────────────────────────────────────────────────

const PALETTE = [
    '#048A81','#c9a84c','#e05252','#5b8dee','#9b59b6',
    '#e67e22','#1abc9c','#e91e63','#3498db','#f39c12'
];


function switchTab(tab) {
    document.getElementById('results').style.display     = tab === 'my-stats' ? '' : 'none';
    document.getElementById('rankingsTab').style.display = tab === 'rankings' ? '' : 'none';
    document.getElementById('tabMyStats').classList.toggle('active',  tab === 'my-stats');
    document.getElementById('tabRankings').classList.toggle('active', tab === 'rankings');
    if (tab === 'rankings') buildGlobalRankings();
}


// ── Rankings filter state ───────────────────────────────────────────────────
let _rankStore       = null; // selected store name or null
let _rankDatePreset  = 'all'; // active preset key

function _getRankDateRange() {
    const now   = new Date();
    const today = now.toISOString().slice(0, 10);

    if (_rankDatePreset === 'custom') {
        const from = document.getElementById('rankDateFrom')?.value || null;
        const to   = document.getElementById('rankDateTo')?.value   || null;
        return { from, to };
    }

    const startOf = (d, unit) => {
        const r = new Date(d);
        if (unit === 'month') { r.setDate(1); }
        if (unit === 'year')  { r.setMonth(0); r.setDate(1); }
        return r.toISOString().slice(0, 10);
    };
    const sub = (d, days) => { const r = new Date(d); r.setDate(r.getDate() - days); return r.toISOString().slice(0, 10); };

    switch (_rankDatePreset) {
        case '7d':         return { from: sub(now, 7),   to: today };
        case '30d':        return { from: sub(now, 30),  to: today };
        case '90d':        return { from: sub(now, 90),  to: today };
        case 'this-month': return { from: startOf(now, 'month'), to: today };
        case 'last-month': {
            const lm = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            const lme = new Date(now.getFullYear(), now.getMonth(), 0);
            return { from: lm.toISOString().slice(0, 10), to: lme.toISOString().slice(0, 10) };
        }
        case 'this-year':  return { from: startOf(now, 'year'), to: today };
        default:           return { from: null, to: null }; // all time
    }
}

function onRankDatePreset(btn) {
    _rankDatePreset = btn.dataset.preset;
    document.querySelectorAll('#rankDatePresetChips .chip').forEach(c =>
        c.classList.toggle('active', c === btn));
    const customRow = document.getElementById('rankCustomDateRow');
    if (customRow) customRow.style.display = _rankDatePreset === 'custom' ? 'flex' : 'none';
    applyRankingsFilter();
}

function _getRankSelectedPeriods() {
    const chips = document.querySelectorAll('#rankPeriodChips .chip:not(.chip-all)');
    return new Set([...chips].filter(c => c.classList.contains('active')).map(c => c.dataset.period));
}

function _getRankSelectedYears() {
    const chips = document.querySelectorAll('#rankYearChips .chip');
    return new Set([...chips].filter(c => c.classList.contains('active')).map(c => c.dataset.year));
}

// Filter a single user's event array using the rankings filter state
function _applyRankFilter(events) {
    const periods       = _getRankSelectedPeriods();
    const years         = _getRankSelectedYears();
    const { from, to }  = _getRankDateRange();
    return events.filter(ev => {
        if (!ev?.rounds) return false;
        if (ev._start_datetime) {
            const dateStr = ev._start_datetime.slice(0, 10);
            const year    = dateStr.slice(0, 4);
            if (years.size > 0 && !years.has(year)) return false;
            if (periods.size > 0) {
                const period = getPeriodForDate(ev._start_datetime);
                if (!periods.has(period)) return false;
            }
            if (from && dateStr < from) return false;
            if (to   && dateStr > to)   return false;
        }
        if (_rankStore && ev._store_name !== _rankStore) return false;
        return true;
    });
}

function onRankYearChip(btn) {
    btn.classList.toggle('active');
    applyRankingsFilter();
}

function onRankStoreChange() {
    _rankStore = document.getElementById('rankStoreSelect').value || null;
    applyRankingsFilter();
}

function clearRankStoreFilter() {
    _rankStore = null;
    document.getElementById('rankStoreSelect').value = '';
    applyRankingsFilter();
}

function clearRankFilters() {
    _rankStore      = null;
    _rankDatePreset = 'all';
    document.getElementById('rankStoreSelect').value = '';
    // Activate all year chips
    document.querySelectorAll('#rankYearChips .chip').forEach(c => c.classList.add('active'));
    // Activate all period chips
    document.querySelectorAll('#rankPeriodChips .chip').forEach(c => c.classList.add('active'));
    // Reset date preset to "All Time"
    document.querySelectorAll('#rankDatePresetChips .chip').forEach(c =>
        c.classList.toggle('active', c.dataset.preset === 'all'));
    const customRow = document.getElementById('rankCustomDateRow');
    if (customRow) customRow.style.display = 'none';
    applyRankingsFilter();
}

function _buildRankFilterChips(allEvents) {
    const periodsWithData = new Set();
    for (const ev of allEvents) {
        if (!ev?._start_datetime) continue;
        periodsWithData.add(getPeriodForDate(ev._start_datetime));
    }

    const container = document.getElementById('rankPeriodChips');
    container.innerHTML = '';

    const allChip = document.createElement('button');
    allChip.className = 'chip chip-all active';
    allChip.textContent = 'All Collections';
    allChip.dataset.period = 'all';
    allChip.onclick = () => {
        const indiv = [...container.querySelectorAll('.chip:not(.chip-all)')];
        const allOn = indiv.every(c => c.classList.contains('active'));
        indiv.forEach(c => c.classList.toggle('active', !allOn));
        allChip.classList.toggle('active', !allOn);
        applyRankingsFilter();
    };
    container.appendChild(allChip);

    for (const p of SET_PERIODS) {
        if (!periodsWithData.has(p.name)) continue;
        const chip = document.createElement('button');
        chip.className = 'chip active';
        chip.textContent = p.name.split(' · ')[0];
        chip.title = p.name;
        chip.dataset.period = p.name;
        chip.onclick = () => {
            chip.classList.toggle('active');
            const indiv = [...container.querySelectorAll('.chip:not(.chip-all)')];
            allChip.classList.toggle('active', indiv.every(c => c.classList.contains('active')));
            applyRankingsFilter();
        };
        container.appendChild(chip);
    }
}

function _buildRankStoreDropdown(allEvents) {
    const stores = new Set(allEvents.map(ev => ev._store_name).filter(Boolean));
    const sel = document.getElementById('rankStoreSelect');
    sel.innerHTML = '<option value="">— all stores —</option>';
    [...stores].sort((a, b) => a.localeCompare(b)).forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
    });
    if (_rankStore && stores.has(_rankStore)) sel.value = _rankStore;
    else _rankStore = null;
}

function _updateRankFilterSummary(allUsers, filteredUsers) {
    const totalEvs    = allUsers.reduce((s, u) => s + u.events.length, 0);
    const filteredEvs = filteredUsers.reduce((s, u) => s + u.events.length, 0);
    const el = document.getElementById('rankFilterSummary');
    if (!el) return;
    el.textContent = filteredEvs < totalEvs
        ? `Showing ${filteredEvs} of ${totalEvs} events`
        : `All ${totalEvs} events`;
}

function applyRankingsFilter() {
    const allUsers = _usersWithToken.map(u => ({
        ...u,
        events: Object.values(loadCache(u.bandaiId) || {})
    })).filter(u => u.events.length > 0);

    const filteredUsers = allUsers.map(u => ({
        ...u,
        events: _applyRankFilter(u.events)
    }));

    _updateRankFilterSummary(allUsers, filteredUsers);
    renderLeaderboard(filteredUsers);
    renderH2HMatrix(filteredUsers);
    renderCommunityOpponents(filteredUsers);
}

function buildGlobalRankings() {
    const allUsers = _usersWithToken.map(u => ({
        ...u,
        events: Object.values(loadCache(u.bandaiId) || {})
    })).filter(u => u.events.length > 0);

    if (allUsers.length === 0) {
        ['leaderboardBody','rankH2H'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.innerHTML = '<p style="color:var(--muted);padding:1rem 0;">No cached data found. Fetch at least one user first.</p>';
        });
        return;
    }

    // Build filter controls from the full (unfiltered) event pool
    const allEvents = allUsers.flatMap(u => u.events);
    _buildRankFilterChips(allEvents);
    _buildRankStoreDropdown(allEvents);

    // Apply any active filters, then render
    applyRankingsFilter();
}

// ── A: Overall Leaderboard ──────────────────────────────────────────────────
let _podiumSort = 'pct'; // 'pct' | 'wins' | 'pts' | 'avgRank'
let _lastLeaderboardUsers = null; // cached so sort buttons can re-render without re-aggregating

function setPodiumSort(mode) {
    _podiumSort = mode;
    document.querySelectorAll('.podium-sort-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.sort === mode);
    });
    if (_lastLeaderboardUsers) renderLeaderboard(_lastLeaderboardUsers);
}

function renderLeaderboard(allUsers) {
    _lastLeaderboardUsers = allUsers;
    const tbody  = document.getElementById('leaderboardBody');
    const podium = document.getElementById('podium');
    if (!tbody) return;

    const rows = allUsers.map(u => {
        let w = 0, l = 0, pts = 0, ranks = [];
        for (const ev of u.events) {
            // Rounds — win/loss counting
            if (ev?.rounds) {
                for (const r of ev.rounds) { if (r.is_win) w++; else l++; }
            }
            // Rank — use preprocessed field, fall back to raw API field for older cached events
            const rank = ev._rank ?? ev.user?.rank ?? null;
            if (rank != null) ranks.push(Number(rank));
            // Match points — same fallback pattern
            const mp = ev._match_points ?? (ev.user?.match_point != null ? Number(ev.user.match_point) : null);
            if (mp != null) pts += mp;
        }
        const total = w + l;
        const pct   = total ? (w / total * 100) : 0;
        const avgRank  = ranks.length ? (ranks.reduce((a,b)=>a+b,0) / ranks.length) : null;
        const bestRank = ranks.length ? Math.min(...ranks) : null;
        return { name: u.name, w, l, total, pct, tournaments: u.events.length, avgRank, bestRank, pts };
    });

    // Sort by the active criterion
    const sorters = {
        pct:     (a, b) => b.pct - a.pct || b.total - a.total,
        wins:    (a, b) => b.w - a.w || b.pct - a.pct,
        pts:     (a, b) => b.pts - a.pts || b.pct - a.pct,
        avgRank: (a, b) => {
            // lower avg rank number = better; nulls go last
            if (a.avgRank == null && b.avgRank == null) return 0;
            if (a.avgRank == null) return 1;
            if (b.avgRank == null) return -1;
            return a.avgRank - b.avgRank;
        },
    };
    rows.sort(sorters[_podiumSort] ?? sorters.pct);

    // ── Podium graphic (top 5) ──────────────────────────────────────────────
    if (podium) {
        const top = rows.slice(0, 5);
        if (top.length === 0) {
            podium.innerHTML = '';
        } else {
            // Classic podium visual order: 4th · 2nd · 1st · 3rd · 5th
            // (only use positions that exist)
            const displayOrder = [3, 1, 0, 2, 4].filter(i => i < top.length);
            const medals = ['🥇','🥈','🥉','',''];

            const initials = name => name.trim().split(/\s+/).map(w => w[0].toUpperCase()).slice(0,2).join('');

            // Primary stat shown in large text — matches the active sort
            const primaryStat = p => {
                switch (_podiumSort) {
                    case 'wins':    return `${p.w}W`;
                    case 'pts':     return `${p.pts} pts`;
                    case 'avgRank': return p.avgRank != null ? `#${p.avgRank.toFixed(1)}` : '—';
                    default:        return `${p.pct.toFixed(1)}%`;
                }
            };

            const slots = displayOrder.map(i => {
                const p   = top[i];
                const pos = i + 1; // 1-based rank
                return `
                <div class="podium-slot" data-pos="${pos}">
                    <div class="podium-avatar">
                        ${initials(p.name)}
                        ${medals[i] ? `<span class="podium-medal">${medals[i]}</span>` : ''}
                    </div>
                    <div class="podium-name" title="${p.name}">${p.name}</div>
                    <div class="podium-pct">${primaryStat(p)}</div>
                    <div class="podium-sub">${p.w}W · ${p.l}L · ${p.pct.toFixed(1)}%<br>${p.tournaments} event${p.tournaments !== 1 ? 's' : ''}</div>
                    <div class="podium-bar">#${pos}</div>
                </div>`;
            }).join('');

            podium.innerHTML = `
                <div class="podium-stage">${slots}</div>
                <div class="podium-floor"></div>`;
        }
    }

    // ── Leaderboard table ───────────────────────────────────────────────────
    const medals = ['🥇','🥈','🥉'];
    tbody.innerHTML = rows.map((r, i) => `
        <tr>
            <td class="td-num">${medals[i] ?? (i+1)}</td>
            <td><strong>${r.name}</strong></td>
            <td class="td-num" style="color:var(--win)">${r.w}</td>
            <td class="td-num" style="color:var(--loss)">${r.l}</td>
            <td class="td-pct" style="color:var(--accent)">${r.pct.toFixed(1)}%</td>
            <td class="td-num">${r.tournaments}</td>
            <td class="td-num">${r.avgRank != null ? r.avgRank.toFixed(1) : '—'}</td>
            <td class="td-num">${r.bestRank != null ? '#' + r.bestRank : '—'}</td>
            <td class="td-num">${r.pts}</td>
        </tr>`).join('');
}

// ── B: Head-to-Head Matrix ──────────────────────────────────────────────────
function renderH2HMatrix(allUsers) {
    const container = document.getElementById('rankH2H');
    if (!container) return;
    if (allUsers.length < 2) {
        container.innerHTML = '<p style="color:var(--muted);">Need at least 2 players with cached data.</p>';
        return;
    }

    // Build bandaiId → index map
    const idxMap = {};
    allUsers.forEach((u, i) => { idxMap[u.bandaiId] = i; });

    // matrix[i][j] = { w: wins by i against j, l: losses by i against j }
    const n = allUsers.length;
    const matrix = Array.from({length: n}, () => Array.from({length: n}, () => ({w:0,l:0})));

    for (let i = 0; i < n; i++) {
        const u = allUsers[i];
        for (const ev of u.events) {
            if (!ev?.rounds) continue;
            for (const r of ev.rounds) {
                const oppId = r.opponent_users?.[0]?.membership_number;
                if (!oppId || !(oppId in idxMap)) continue;
                const j = idxMap[oppId];
                if (i === j) continue;
                if (r.is_win) matrix[i][j].w++; else matrix[i][j].l++;
            }
        }
    }

    // Render table
    const headerCells = allUsers.map(u =>
        `<th style="padding:0.45rem 0.6rem;background:linear-gradient(135deg,var(--primary),#3d5472);color:white;font-family:'Cinzel',serif;font-size:0.7rem;text-align:center;white-space:nowrap;">${u.name}</th>`
    ).join('');

    const bodyRows = allUsers.map((u, i) => {
        const cells = allUsers.map((_, j) => {
            if (i === j) return `<td class="h2h-self">—</td>`;
            const {w, l} = matrix[i][j];
            if (w === 0 && l === 0) return `<td style="color:var(--muted);text-align:center;">-</td>`;
            const cls = w > l ? 'h2h-win' : (l > w ? 'h2h-loss' : '');
            return `<td class="${cls}">${w}–${l}</td>`;
        }).join('');
        return `<tr><td class="h2h-label">${u.name}</td>${cells}</tr>`;
    }).join('');

    container.innerHTML = `
        <table class="h2h-table">
            <thead><tr>
                <th style="padding:0.45rem 0.6rem;background:linear-gradient(135deg,var(--primary),#3d5472);color:white;font-family:'Cinzel',serif;font-size:0.7rem;">vs ↓</th>
                ${headerCells}
            </tr></thead>
            <tbody>${bodyRows}</tbody>
        </table>`;
}

// ── D: Community Opponents ──────────────────────────────────────────────────
function renderCommunityOpponents(allUsers) {
    const card = document.getElementById('communityOppCard');
    if (!card) return;
    const trackedIds = new Set(allUsers.map(u => u.bandaiId));
    const oppCount   = {};

    for (const u of allUsers) {
        for (const ev of u.events) {
            if (!ev?.rounds) continue;
            for (const r of ev.rounds) {
                const pid   = r.opponent_users?.[0]?.membership_number;
                const pName = r.opponent_users?.[0]?.player_name?.trim();
                if (!pid || trackedIds.has(pid)) continue;
                if (pName && !_usernameMap[pid]) _usernameMap[pid] = pName;
                if (!oppCount[pid]) oppCount[pid] = { matches: 0, players: new Set() };
                oppCount[pid].matches++;
                oppCount[pid].players.add(u.bandaiId);
            }
        }
    }

    const top = Object.entries(oppCount)
        .sort((a, b) => b[1].matches - a[1].matches)
        .slice(0, 20);

    if (top.length === 0) { card.style.display = 'none'; return; }
    card.style.display = 'block';

    const tbody = document.getElementById('communityOppBody');
    tbody.innerHTML = '';
    for (const [pid, data] of top) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${_usernameMap[pid] || pid}</td>
            <td class="td-num">${data.matches}</td>
            <td class="td-num">${data.players.size}</td>`;
        tbody.appendChild(tr);
    }
}

// ── PDF export ─────────────────────────────────────────────────────────────

function exportPDF() {
    // Remember which card bodies were collapsed
    const wasCollapsed = [...document.querySelectorAll('.card-body.collapsed')];

    // Expand them all so content prints
    wasCollapsed.forEach(body => body.classList.remove('collapsed'));

    // Restore collapsed state after the print dialog closes
    function restore() {
        wasCollapsed.forEach(body => body.classList.add('collapsed'));
        window.removeEventListener('afterprint', restore);
    }
    window.addEventListener('afterprint', restore);

    window.print();
}

// ── Export ─────────────────────────────────────────────────────────────────

function exportExcel() {
    if (!_playerResults) return;
    const sorted = Object.entries(_playerResults)
        .sort((a, b) => (b[1][0] + b[1][1]) - (a[1][0] + a[1][1]));

    const data = [["Player", "W", "L", "Total", "Win%"]];
    for (const [pid, res] of sorted) {
        const tag   = _usernameMap[pid] || pid;
        const [w, l] = res;
        const t     = w + l;
        const pct   = t > 0 ? parseFloat((w / t * 100).toFixed(1)) : 0;
        data.push([tag, w, l, t, pct]);
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(data);
    ws['!cols'] = [{ wch: 24 }, { wch: 6 }, { wch: 6 }, { wch: 8 }, { wch: 8 }];
    XLSX.utils.book_append_sheet(wb, ws, "Results");
    XLSX.writeFile(wb, "bandai_results.xlsx");
}

function exportCSV() {
    if (!_allEventData || _allEventData.length === 0) return;

    function dl(filename, rows) {
        const csv = rows.map(r =>
            r.map(v => {
                const s = String(v ?? '');
                return s.includes(',') || s.includes('"') || s.includes('\n') ? `"${s.replace(/"/g, '""')}"` : s;
            }).join(',')
        ).join('\r\n');
        const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    const evs = [..._allEventData]
        .filter(ev => ev?.rounds)
        .sort((a, b) => (a._start_datetime || '').localeCompare(b._start_datetime || ''));

    // 1. Tournament history
    const tourRows = [['Date', 'Event', 'Store', 'W', 'L', 'Game W', 'Game L', 'Win%', 'Rank', 'Points']];
    for (const ev of evs) {
        let evW = 0, evL = 0, evGW = 0, evGL = 0;
        for (const r of ev.rounds) {
            if (r.is_win) evW++; else evL++;
            evGW += r.win_count  != null ? r.win_count  : (r.is_win ? 1 : 0);
            evGL += r.lose_count != null ? r.lose_count : (r.is_win ? 0 : 1);
        }
        const t = evW + evL;
        tourRows.push([
            ev._start_datetime ? ev._start_datetime.slice(0, 10) : '',
            ev._event_name ?? '',
            ev._store_name ?? '',
            evW, evL, evGW, evGL,
            t > 0 ? (evW / t * 100).toFixed(1) + '%' : '—',
            ev._rank != null ? ev._rank : '',
            ev._match_points != null ? ev._match_points : ''
        ]);
    }
    dl('bandai_tournament_history.csv', tourRows);

    // 2. Opponent history (from _playerResults)
    setTimeout(() => {
        if (!_playerResults) return;
        const oppRows = [['Player', 'W', 'L', 'Total', 'Win%']];
        const sorted = Object.entries(_playerResults).sort((a, b) => (b[1][0]+b[1][1]) - (a[1][0]+a[1][1]));
        for (const [pid, res] of sorted) {
            const [w, l] = res;
            const t = w + l;
            oppRows.push([_usernameMap[pid] || pid, w, l, t, t > 0 ? (w/t*100).toFixed(1)+'%' : '—']);
        }
        dl('bandai_opponent_history.csv', oppRows);
    }, 300);

    // 3. Round-by-round detail
    setTimeout(() => {
        const rndRows = [['Date', 'Event', 'Round', 'Opponent', 'Result', 'Score']];
        for (const ev of evs) {
            const date  = ev._start_datetime ? ev._start_datetime.slice(0, 10) : '';
            const name  = ev._event_name ?? '';
            for (const r of ev.rounds) {
                const opp    = r.opponent_users?.[0]?.player_name ?? r.opponent_users?.[0]?.membership_number ?? '—';
                const result = r.is_win ? 'Win' : 'Loss';
                const gw = r.win_count  != null ? r.win_count  : (r.is_win ? 1 : 0);
                const gl = r.lose_count != null ? r.lose_count : (r.is_win ? 0 : 1);
                rndRows.push([date, name, r.round_no ?? '—', opp, result, `${gw}-${gl}`]);
            }
        }
        dl('bandai_rounds.csv', rndRows);
    }, 600);
}
</script>
</body>
</html>
